"use strict";(self.webpackChunkdocumentation_site=self.webpackChunkdocumentation_site||[]).push([[81415],{43864:(t,s,e)=>{e.r(s),e.d(s,{assets:()=>c,contentTitle:()=>a,default:()=>h,frontMatter:()=>r,metadata:()=>n,toc:()=>l});const n=JSON.parse('{"id":"writing-constraint-systems/witnesses","title":"Witnesses","description":"In a constraint system, a witness is kind of like a blank space that is purposefully left to be filled in by the prover. The size","source":"@site/docs/writing-constraint-systems/witnesses.mdx","sourceDirName":"writing-constraint-systems","slug":"/writing-constraint-systems/witnesses","permalink":"/o1js/writing-constraint-systems/witnesses","draft":false,"unlisted":false,"editUrl":"https://github.com/docs/writing-constraint-systems/witnesses.mdx","tags":[],"version":"current","frontMatter":{"title":"Witnesses"},"sidebar":"docs","previous":{"title":"Hashing","permalink":"/o1js/basic-types/hashing"},"next":{"title":"Conditional Logic","permalink":"/o1js/writing-constraint-systems/conditional-logic"}}');var i=e(74848),o=e(28453);e(58069);const r={title:"Witnesses"},a=void 0,c={},l=[];function d(t){const s={admonition:"admonition",code:"code",p:"p",pre:"pre",...(0,o.R)(),...t.components};return(0,i.jsxs)(i.Fragment,{children:[(0,i.jsx)(s.p,{children:"In a constraint system, a witness is kind of like a blank space that is purposefully left to be filled in by the prover. The size\nand shape of a witness must be known at compile time, but the value does not need to be known until the\nprover generates a proof."}),"\n",(0,i.jsxs)(s.p,{children:['Witnesses are useful because they allow you to "witness in" arbitrary data into a proof.  A classic use case is to compute square\nroot.  It is trivial to prove that ',(0,i.jsx)(s.code,{children:"x * x = y"}),", and it is not trivial to prove that ",(0,i.jsx)(s.code,{children:"x = sqrt(y)"}),".  Using a witness, we can use\nthe triviality of multiplication to prove square root."]}),"\n",(0,i.jsxs)(s.admonition,{type:"info",children:[(0,i.jsx)(s.p,{children:'Another way to think about witnesses is to think of the math expression "there exists...such that ...".  For instance, "there\nexists a number x such that x * x = y".  The witness is the value of x, the constraints added to the circuit are the "such that"\npart.'}),(0,i.jsxs)(s.p,{children:["Fun fact: Witness is referred to as ",(0,i.jsx)(s.code,{children:"exists"})," internally."]})]}),"\n",(0,i.jsx)(s.pre,{children:(0,i.jsx)(s.code,{className:"language-ts",metastring:"file=../snippets/witnesses/witnesses.ts start=start_sqrt end=end_sqrt",children:"const x = 10;\n\n// unconstrained value of type UInt32\nconst w_sqrt = Provable.witness(UInt32, () => {\n  return UInt32.from(x);\n});\n\n// constraint added to w_sqrt to prove that it satisfies the square root function\nw_sqrt.mul(w_sqrt).assertEquals(UInt32.from(100));\n"})})]})}function h(t={}){const{wrapper:s}={...(0,o.R)(),...t.components};return s?(0,i.jsx)(s,{...t,children:(0,i.jsx)(d,{...t})}):d(t)}}}]);