"use strict";(self.webpackChunkdocumentation_site=self.webpackChunkdocumentation_site||[]).push([[44455],{10169:(e,s,t)=>{t.r(s),t.d(s,{assets:()=>o,contentTitle:()=>d,default:()=>h,frontMatter:()=>l,metadata:()=>i,toc:()=>c});const i=JSON.parse('{"id":"basic-types/field","title":"Field","description":"Field","source":"@site/versioned_docs/version-2.4.0/basic-types/field.mdx","sourceDirName":"basic-types","slug":"/basic-types/field","permalink":"/o1js/2.4.0/basic-types/field","draft":false,"unlisted":false,"editUrl":"https://github.com/versioned_docs/version-2.4.0/basic-types/field.mdx","tags":[],"version":"2.4.0","frontMatter":{"title":"Field"},"sidebar":"docs","previous":{"title":"What is a ZK Constraint System?","permalink":"/o1js/2.4.0/getting-started/what-is-a-zk-constraint-system"},"next":{"title":"Integers","permalink":"/o1js/2.4.0/basic-types/int"}}');var n=t(74848),a=t(28453),r=(t(58069),t(75489));const l={title:"Field"},d=void 0,o={},c=[{value:"Field",id:"field",level:2},{value:"Overflow Behavior",id:"overflow-behavior",level:3}];function p(e){const s={a:"a",admonition:"admonition",code:"code",h2:"h2",h3:"h3",p:"p",pre:"pre",...(0,a.R)(),...e.components};return(0,n.jsxs)(n.Fragment,{children:[(0,n.jsx)(s.h2,{id:"field",children:"Field"}),"\n",(0,n.jsx)(s.p,{children:"Field elements are the basic unit of data in zero knowledge proof programming.  An element of a Field is like an integer, except that all operations\nare performed modulo a prime.  Each field element can store a number up to almost 256 bits in size.  All other data types that can be used in\nprovable code can be represented as Fields."}),"\n",(0,n.jsx)(s.admonition,{type:"note",children:(0,n.jsxs)(s.p,{children:["For the cryptography inclined, the exact max value that a field can store is: ",BigInt(r.X).toLocaleString(),"."]})}),"\n",(0,n.jsx)(s.p,{children:"For example, in typical programming, you might use:"}),"\n",(0,n.jsxs)(s.p,{children:[(0,n.jsx)(s.code,{children:"const sum = 1 + 3;"}),"."]}),"\n",(0,n.jsx)(s.p,{children:"In o1js, you write this as:"}),"\n",(0,n.jsx)(s.pre,{children:(0,n.jsx)(s.code,{className:"language-ts",metastring:"file=../snippets/field/field.ts start=start_sum_1 end=end_sum_1",children:"const sum1 = new Field(1).add(new Field(3));\n"})}),"\n",(0,n.jsx)(s.p,{children:"This can be simplified as:"}),"\n",(0,n.jsx)(s.pre,{children:(0,n.jsx)(s.code,{className:"language-ts",metastring:"file=../snippets/field/field.ts start=start_sum_2 end=end_sum_2",children:"// Note that the `3` is automatically converted to a Field instance.\nconst sum2 = new Field(1).add(3);\n"})}),"\n",(0,n.jsx)(s.h3,{id:"overflow-behavior",children:"Overflow Behavior"}),"\n",(0,n.jsxs)(s.p,{children:["Field arithmetic supports overflow and underflow.  See ",(0,n.jsx)(s.a,{href:"/o1js/basic-types/int",children:"Integers"})," for an o1js type that behaves more like a traditional integer type."]}),"\n",(0,n.jsx)(s.pre,{children:(0,n.jsx)(s.code,{className:"language-ts",metastring:"file=../snippets/field/field.ts start=start_overflow end=end_overflow",children:"// The result is 0 because the sum overflows.\nconst overflow = new Field(Field.ORDER - 1n).add(1);\n"})}),"\n",(0,n.jsx)(s.pre,{children:(0,n.jsx)(s.code,{className:"language-ts",metastring:"file=../snippets/field/field.ts start=start_underflow end=end_underflow",children:"// The result is equivalent to the order of the field minus 1 because the subtraction underflows.\nconst underflow = new Field(0).sub(1);\n"})}),"\n",(0,n.jsxs)(s.p,{children:["Read more at the language reference: ",(0,n.jsx)(s.a,{href:"/o1js/api-reference/classes/Field",children:"Field"}),"."]})]})}function h(e={}){const{wrapper:s}={...(0,a.R)(),...e.components};return s?(0,n.jsx)(s,{...e,children:(0,n.jsx)(p,{...e})}):p(e)}},75489:e=>{e.exports=JSON.parse('{"X":"28948022309329048855892746252171976963363056481941560715954676764349967630337"}')}}]);