"use strict";(self.webpackChunkdocumentation_site=self.webpackChunkdocumentation_site||[]).push([[22354],{93107:(e,t,n)=>{n.r(t),n.d(t,{assets:()=>l,contentTitle:()=>r,default:()=>h,frontMatter:()=>s,metadata:()=>i,toc:()=>c});const i=JSON.parse('{"id":"getting-started/what-is-a-zk-constraint-system","title":"What is a ZK Constraint System?","description":"In order to write effective o1js, you need to understand at least the basics of ZK constraint","source":"@site/docs/getting-started/what-is-a-zk-constraint-system.mdx","sourceDirName":"getting-started","slug":"/getting-started/what-is-a-zk-constraint-system","permalink":"/o1js/getting-started/what-is-a-zk-constraint-system","draft":false,"unlisted":false,"editUrl":"https://github.com/docs/getting-started/what-is-a-zk-constraint-system.mdx","tags":[],"version":"current","frontMatter":{"title":"What is a ZK Constraint System?"},"sidebar":"docs","previous":{"title":"Welcome","permalink":"/o1js/"},"next":{"title":"Field","permalink":"/o1js/basic-types/field"}}');var o=n(74848),a=n(28453);n(58069);const s={title:"What is a ZK Constraint System?"},r=void 0,l={},c=[{value:"Implications for Developers",id:"implications-for-developers",level:2},{value:"No Dynamic Programming",id:"no-dynamic-programming",level:3},{value:"No Conditional Execution",id:"no-conditional-execution",level:3},{value:"Rule of Thumb: Prove the Smallest Thing",id:"rule-of-thumb-prove-the-smallest-thing",level:3}];function m(e){const t={a:"a",code:"code",em:"em",h2:"h2",h3:"h3",p:"p",pre:"pre",...(0,a.R)(),...e.components};return(0,o.jsxs)(o.Fragment,{children:[(0,o.jsx)(t.p,{children:"In order to write effective o1js, you need to understand at least the basics of ZK constraint\nsystems.  If you're coming from a background in web2 or web3, you should try to get a sense\nfor the fundamental differences between zk programming and programming in traditional compiled\nand interpreted programming languages before getting deep into working with o1js.  If you're\ncoming from a background writing circuits with other DSLs, then this article may be just a\nrefresher!"}),"\n",(0,o.jsx)(t.p,{children:"You can think of a constraint system as an array of gates.  Each gate is a simple math problem\nthat the prover knows how to verifiably compute that accepts some coefficients as input and\npasses along some output to the next gate.  As a mental model, you can think of gates in a\nproof system like instructions on a CPU.  A constraint system, then, is like a program that\nis composed of a list of instructions to execute in order."}),"\n",(0,o.jsxs)(t.p,{children:["Don't take the metaphor too far!  Most proof systems don't operate over binary data like a\nCPU does, and they don't have an analogous gate to ",(0,o.jsx)(t.code,{children:"JUMP"})," or ",(0,o.jsx)(t.code,{children:"GOTO"}),", which means that\nconditional execution is not supported."]}),"\n",(0,o.jsx)(t.p,{children:"TODO: We could use an illustration here too"}),"\n",(0,o.jsxs)(t.p,{children:["Currently, o1js is compatible with the Kimchi proof backend (via a circuit-writing frontend\ncalled snarky), which is specified in the ",(0,o.jsx)(t.a,{href:"https://o1-labs.github.io/proof-systems/specs/kimchi.html",children:"Mina Book"}),"."]}),"\n",(0,o.jsx)(t.h2,{id:"implications-for-developers",children:"Implications for Developers"}),"\n",(0,o.jsx)(t.p,{children:"There are two important implications that effect almost every ZK developer.  Before getting\ninto code examples, you should be thinking about how this programming paradigm will change\nthe way you think about your code."}),"\n",(0,o.jsx)(t.h3,{id:"no-dynamic-programming",children:"No Dynamic Programming"}),"\n",(0,o.jsx)(t.p,{children:'When writing o1js, a common pattern is to "compile" a constraint system, then generate a proof\nwith the compiled artifact.  We call the time while the constraint system is being built for\nthe first time "compile time", and the time when the proof is being generated against that\nartifact "prover time".  This process is similar to how a compiler works in a traditional\nprogramming language.  The compiler takes a program, and generates an artifact in a more raw\nform.  Traditionally, the compiler converts between a high level language that is human readable\nand a low level language that is CPU readable.  In o1js, the compiler takes a high level\nlanguage and converts it to a constraint system that is executable by a prover or verifier.'}),"\n",(0,o.jsxs)(t.p,{children:["At compile time, and at prover time, the constraint system needs to be identical.  So if you\nconsider a common tool in programming, a dynamic loop, it won't work in ZK.  When you compile\nthe circuit, a dummy value will be used for the variables, and it will follow some execution\npath.  Then all subsequent calls to the function must follow ",(0,o.jsx)(t.em,{children:"exactly"})," the same path.  That\nmeans different values of a variable can't result in different numbers of iterations over a\nloop."]}),"\n",(0,o.jsx)(t.p,{children:"There are workarounds for this.  For instance, you can write constraint systems that execute\na single step, and call the prover function a dynamic number of times.  Or you can execute a\nloop a fixed number of times, but with some dummy behavior.  Consider this normal Javascript\ncode:"}),"\n",(0,o.jsx)(t.pre,{children:(0,o.jsx)(t.code,{className:"language-ts",children:"function multiplyAll(arr: number[]) {\n    let result = 1;\n    // This loop can be unbounded - At compile time, it will iterate 0 times, assuming we use a dummy value of [] for arr\n    // At prover time, it will iterate arr.length times, resulting in a different constraint system, so the proof will not be valid\n    for (let i = 0; i < arr.length; i++) {\n        result *= arr[i];\n    }\n    return result;\n}\n"})}),"\n",(0,o.jsx)(t.p,{children:'The function isn\'t "ZK friendly" because the number of iterations over the loop is dynamic.\nTo re-imagine this function for ZK, we can fix the size of the array, and fill the rest of\nthe array with ones, which will not affect the result of the multiplication:'}),"\n",(0,o.jsx)(t.pre,{children:(0,o.jsx)(t.code,{className:"language-ts",children:"// NOTE: This is pseudo code, not valid o1js - proper provable code wraps all data in provable types\nfunction multiplyAll(arr: number[]) {\n    let result = 1;\n    // This loop is fixed size - At compile time, it will iterate 10 times, regardless of the size of arr\n    // At prover time, it will iterate 10 times, therefore the same constraint system will be generated, and the proof will be valid\n    // NOTE: Again this is pseudo code, imagine that there is no index out of bounds error with arr[i]\n    for (let i = 0; i < 10; i++) {\n        result *= arr[i] || 1;\n    }\n    return result;\n}\n"})}),"\n",(0,o.jsxs)(t.p,{children:["This way, the function will always iterate 10 times, and for any input of less than or equal\nto ten elements, the result will be the same.  Note that for arrays larger than ten, the\nresult will ",(0,o.jsx)(t.em,{children:"not"})," be the same.  You must carefully write your constraint systems to be\ncompatible with your domain."]}),"\n",(0,o.jsx)(t.h3,{id:"no-conditional-execution",children:"No Conditional Execution"}),"\n",(0,o.jsxs)(t.p,{children:["Along the same lines, a function can't execute a different code path based on the value of a\nvariable.  There are ways to conditionally assign values to variables (see:\n",(0,o.jsx)(t.a,{href:"/o1js/writing-constraint-systems/conditional-logic",children:"Conditional Logic"}),"), but the\nexecution path must always be identical."]}),"\n",(0,o.jsx)(t.h3,{id:"rule-of-thumb-prove-the-smallest-thing",children:"Rule of Thumb: Prove the Smallest Thing"}),"\n",(0,o.jsx)(t.p,{children:"A programming language with no dynamic programming and no conditional execution may sound\nuseless at first, but you don't need to write your entire application in ZK.  ZK is a spice\nthat you can use sparingly to supercharge your application.  When you specifically need to\nprove something for privacy, scale, or security, you can write a constraint system to\nmodel the problem you want to solve.  What's amazing about o1js is that you can expose that\nconstraint system system directly to users in a browser, or to a service that can access\nnode.  Design apps that use constraint systems with as little scope as possible to maximize\nperformance and developer experience."}),"\n",(0,o.jsxs)(t.p,{children:["The tradeoffs regarding dynamic programming and conditional execution can also be worked\naround by writing small, well-scoped constraint systems.  Your JavaScript code can make\nuse of dynamic programming and compose simple proofs into more complex proofs.  Imagine\nyou are writing a sudoku solver.  A na\xefve approach would be to model the entire solver\nin o1js and make it provable.  But if you break the problem down, ",(0,o.jsx)(t.em,{children:"solving"})," the sudoku\ndoesn't need to be provable, only ",(0,o.jsx)(t.em,{children:"verifying"})," the solution does.  So you can write a\nJavaScript solver that uses dynamic programming to solve the sudoku simply, and write an\no1js constraint system to verify the solution for any given input.  You can even write a\nconstraint system that verifies the proof of a single solution, and adds the solution to\na list of known solutions.  By writing simple constraint systems, that do one thing well,\nyou can compose more complex systems that prove interesting things."]})]})}function h(e={}){const{wrapper:t}={...(0,a.R)(),...e.components};return t?(0,o.jsx)(t,{...e,children:(0,o.jsx)(m,{...e})}):m(e)}}}]);