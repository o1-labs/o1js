"use strict";(self.webpackChunkdocumentation_site=self.webpackChunkdocumentation_site||[]).push([[82301],{88716:(e,t,n)=>{n.r(t),n.d(t,{assets:()=>c,contentTitle:()=>r,default:()=>m,frontMatter:()=>o,metadata:()=>s,toc:()=>p});const s=JSON.parse('{"id":"tutorials/hmac/implementation","title":"HMAC-SHA256 Implementation","description":"Complete HMAC-SHA256 zero-knowledge circuit in o1js","source":"@site/docs/tutorials/hmac/02-implementation.mdx","sourceDirName":"tutorials/hmac","slug":"/tutorials/hmac/implementation","permalink":"/o1js/tutorials/hmac/implementation","draft":false,"unlisted":false,"editUrl":"https://github.com/docs/tutorials/hmac/02-implementation.mdx","tags":[],"version":"current","sidebarPosition":2,"frontMatter":{"title":"HMAC-SHA256 Implementation","sidebar_label":"Implementation","description":"Complete HMAC-SHA256 zero-knowledge circuit in o1js","pagination_prev":"tutorials/hmac/hmac-basics","pagination_next":"tutorials/hmac/tests"},"sidebar":"docs","previous":{"title":"Understanding the Algorithm","permalink":"/o1js/tutorials/hmac/hmac-basics"},"next":{"title":"Tests","permalink":"/o1js/tutorials/hmac/tests"}}');var a=n(74848),i=n(28453);n(58069);const o={title:"HMAC-SHA256 Implementation",sidebar_label:"Implementation",description:"Complete HMAC-SHA256 zero-knowledge circuit in o1js",pagination_prev:"tutorials/hmac/hmac-basics",pagination_next:"tutorials/hmac/tests"},r=void 0,c={},p=[];function l(e){const t={code:"code",p:"p",pre:"pre",...(0,i.R)(),...e.components};return(0,a.jsxs)(a.Fragment,{children:[(0,a.jsx)(t.p,{children:"Here's our complete implementation:"}),"\n",(0,a.jsx)(t.pre,{children:(0,a.jsx)(t.code,{className:"language-ts",metastring:"file=../../snippets/hmac-sha256/hmac-sha256.ts",children:'// https://github.com/o1-labs-XT/hmac-sha256-o1js/blob/main/src/hmac-sha256.ts\n\nimport { Bytes, Hash, UInt32, FlexibleBytes, Provable, UInt8 } from "o1js";\n\n/**\n * Implementation of HMAC-SHA256 (Hash-based Message Authentication Code using SHA-256)\n * Following the standard HMAC construction:\n * HMAC(K,m) = H((k_0 ^ opad) || H((k_0 ^ ipad) || m))\n * where:\n * - k_0 is the input key (padded/hashed if necessary)\n * - ipad is the inner padding (0x36 repeated)\n * - opad is the outer padding (0x5c repeated)\n * - H is SHA-256 hash function\n * - || denotes concatenation\n * - ^ denotes XOR operation\n */\nexport class HMAC_SHA256 {\n  static readonly IPAD = UInt32.from(0x36363636); // Inner padding constant\n  static readonly OPAD = UInt32.from(0x5c5c5c5c); // Outer padding constant\n  static readonly BLOCK_SIZE = 64; // Block size for SHA256 (512 bits / 64 bytes)\n\n  // start_keyprep\n  /**\n   * Prepares a key for HMAC-SHA256 computation according to the HMAC specification (RFC 2104).\n   *\n   * If the key is longer than the block size (64 bytes):\n   * - The key is first hashed using SHA-256 to produce a 32-byte key\n   * - Then the 32-byte key is padded with zeros to reach the block size (64 bytes)\n   *\n   * If the key is shorter than the block size:\n   * - The key is padded with zeros to reach the block size\n   *\n   * If the key is exactly the block size:\n   * - The key is used as-is\n   *\n   * @param key - The input key as FlexibleBytes\n   * @returns A standardized key of exactly BLOCK_SIZE (64) bytes\n   */\n  static prepareKey(key: FlexibleBytes): Bytes {\n    let keyBuffer = Bytes.from(key);\n\n    if (key.length > this.BLOCK_SIZE) {\n      const hashedKeyBuffer = Hash.SHA2_256.hash(key);\n      keyBuffer = Bytes.from(hashedKeyBuffer);\n    }\n\n    if (keyBuffer.length < this.BLOCK_SIZE) {\n      keyBuffer = Bytes(this.BLOCK_SIZE).from(keyBuffer.bytes);\n    }\n\n    return keyBuffer;\n  }\n  // end_keyprep\n\n  /**\n   * Computes HMAC-SHA256 for given key and message\n   * @param key - The key for HMAC as FlexibleBytes\n   * @param message - The message to authenticate as FlexibleBytes\n   * @returns The HMAC hash as Bytes\n   */\n  static compute(key: FlexibleBytes, message: FlexibleBytes): Bytes {\n    // Step 1: k_0\n    const k0 = this.prepareKey(key);\n\n    // Convert padded key to UInt32 array for XOR operations\n    const k0Uint32 = Provable.Array(UInt32, 16).empty();\n    const k0Bytes = Provable.Array(UInt8, this.BLOCK_SIZE).empty();\n\n    // Copy the key bytes into a provable array\n    for (let i = 0; i < this.BLOCK_SIZE; i++) {\n      k0Bytes[i] = k0.bytes[i];\n    }\n\n    // Construct each UInt32 from 4 bytes with proper byte ordering\n    for (let i = 0; i < 16; i++) {\n      k0Uint32[i] = UInt32.fromBytes([\n        k0Bytes[i * 4 + 3],\n        k0Bytes[i * 4 + 2],\n        k0Bytes[i * 4 + 1],\n        k0Bytes[i * 4 + 0],\n      ]);\n    }\n\n    // Step 2: k_0 ^ ipad\n    const k0IpadXor = Provable.Array(UInt32, 16).empty();\n    for (let i = 0; i < 16; i++) {\n      k0IpadXor[i] = k0Uint32[i].xor(this.IPAD);\n    }\n\n    // Step 3: (k_0 ^ ipad) || message\n    const k0IpadBytes = Provable.Array(UInt8, this.BLOCK_SIZE).empty();\n    for (let i = 0; i < 16; i++) {\n      const ipadBytes = k0IpadXor[i].toBytes();\n      k0IpadBytes[i * 4 + 0] = ipadBytes[3];\n      k0IpadBytes[i * 4 + 1] = ipadBytes[2];\n      k0IpadBytes[i * 4 + 2] = ipadBytes[1];\n      k0IpadBytes[i * 4 + 3] = ipadBytes[0];\n    }\n\n    const messageBytes = Bytes.from(message).bytes;\n    const innerBlock = Provable.Array(\n      UInt8,\n      this.BLOCK_SIZE + messageBytes.length\n    ).empty();\n\n    for (let i = 0; i < this.BLOCK_SIZE; i++) {\n      innerBlock[i] = k0IpadBytes[i];\n    }\n    for (let i = 0; i < messageBytes.length; i++) {\n      innerBlock[this.BLOCK_SIZE + i] = messageBytes[i];\n    }\n\n    // Step 4: H((k_0 ^ ipad) || message)\n    const innerHash = Hash.SHA2_256.hash(innerBlock);\n\n    // Step 5: k_0 ^ opad\n    const k0OpadXor = Provable.Array(UInt32, 16).empty();\n    for (let i = 0; i < 16; i++) {\n      k0OpadXor[i] = k0Uint32[i].xor(this.OPAD);\n    }\n\n    // Step 6: (k_0 ^ opad) || H((k_0 ^ ipad) || message)\n    const k0OpadBytes = Provable.Array(UInt8, this.BLOCK_SIZE).empty();\n    for (let i = 0; i < 16; i++) {\n      const opadBytes = k0OpadXor[i].toBytes();\n      k0OpadBytes[i * 4 + 0] = opadBytes[3];\n      k0OpadBytes[i * 4 + 1] = opadBytes[2];\n      k0OpadBytes[i * 4 + 2] = opadBytes[1];\n      k0OpadBytes[i * 4 + 3] = opadBytes[0];\n    }\n\n    const outerBlock = Provable.Array(UInt8, this.BLOCK_SIZE + 32).empty();\n    for (let i = 0; i < this.BLOCK_SIZE; i++) {\n      outerBlock[i] = k0OpadBytes[i];\n    }\n    for (let i = 0; i < 32; i++) {\n      outerBlock[this.BLOCK_SIZE + i] = innerHash.bytes[i];\n    }\n\n    // Step 7: H((k_0 ^ opad) || H((k_0 ^ ipad) || message))\n    return Hash.SHA2_256.hash(outerBlock);\n  }\n}\n'})}),"\n",(0,a.jsx)(t.p,{children:"With o1js, you can compose HMAC proofs with other zero-knowledge circuits. Here's how to integrate it into your ZkProgram:"}),"\n",(0,a.jsx)(t.pre,{children:(0,a.jsx)(t.code,{className:"language-ts",metastring:"file=../../snippets/hmac-sha256/run.ts",children:"import { ZkProgram, Bytes } from 'o1js';\nimport { HMAC_SHA256 } from './hmac-sha256.js';\n\nexport let hmacSha256ZkProgram = ZkProgram({\n  name: 'hmac-sha256-verify',\n  publicOutput: Bytes(32), // HMAC-SHA256 Hash (256 bits / 32 bytes)\n  methods: {\n    verifyHmac: {\n      privateInputs: [\n        Bytes(64), // Key (512 bits / 64 bytes)\n        Bytes(64), // Message (512 bits / 64 bytes)\n      ],\n\n      async method(key: Bytes, message: Bytes) {\n        const hash = HMAC_SHA256.compute(key, message);\n        return { publicOutput: hash };\n      },\n    },\n  },\n});\n\nconst key = Bytes(64).fromString(\n  '4q72JHgX89z3BkFMt6cwQxL1rD28jpN5UfVhIZYPbCSeuGovRaWmA0sD9ECtX7Jf'\n);\nconst message = Bytes(64).fromString(\n  'ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789+/'\n);\n\nlet { verifyHmac } = await hmacSha256ZkProgram.analyzeMethods();\n\nconsole.log(verifyHmac.summary());\n\nconsole.time('Compile');\nconst forceRecompileEnabled = false;\nawait hmacSha256ZkProgram.compile({ forceRecompile: forceRecompileEnabled });\nconsole.timeEnd('Compile');\n\nconsole.time('Prove');\nlet { proof } = await hmacSha256ZkProgram.verifyHmac(key, message);\nconsole.timeEnd('Prove');\n\nconst hashHex = proof.publicOutput.toHex();\nconsole.log('Final HMAC-SHA256 hash:', hashHex);\n\nconsole.time('Verify');\nawait proof.verify();\nconsole.timeEnd('Verify');\n"})})]})}function m(e={}){const{wrapper:t}={...(0,i.R)(),...e.components};return t?(0,a.jsx)(t,{...e,children:(0,a.jsx)(l,{...e})}):l(e)}}}]);