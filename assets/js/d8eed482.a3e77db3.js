"use strict";(self.webpackChunkdocumentation_site=self.webpackChunkdocumentation_site||[]).push([[13267],{28453:(e,n,r)=>{r.d(n,{R:()=>s,x:()=>d});var o=r(96540);const i={},c=o.createContext(i);function s(e){const n=o.useContext(c);return o.useMemo((function(){return"function"==typeof e?e(n):{...n,...e}}),[n,e])}function d(e){let n;return n=e.disableParentContext?"function"==typeof e.components?e.components(i):e.components||i:s(e.components),o.createElement(c.Provider,{value:n},e.children)}},40738:(e,n,r)=>{r.r(n),r.d(n,{assets:()=>t,contentTitle:()=>d,default:()=>h,frontMatter:()=>s,metadata:()=>o,toc:()=>l});const o=JSON.parse('{"id":"api-reference/functions/ZkProgram","title":"ZkProgram","description":"Defined in224","source":"@site/docs/api-reference/functions/ZkProgram.mdx","sourceDirName":"api-reference/functions","slug":"/api-reference/functions/ZkProgram","permalink":"/o1js/api-reference/functions/ZkProgram","draft":false,"unlisted":false,"editUrl":"https://github.com/docs/api-reference/functions/ZkProgram.mdx","tags":[],"version":"current","frontMatter":{},"sidebar":"docs","previous":{"title":"WithHash","permalink":"/o1js/api-reference/functions/WithHash"},"next":{"title":"addCachedAccount","permalink":"/o1js/api-reference/functions/addCachedAccount"}}');var i=r(74848),c=r(28453);const s={},d=void 0,t={},l=[{value:"Type Parameters",id:"type-parameters",level:2},{value:"Parameters",id:"parameters",level:2},{value:"config",id:"config",level:3},{value:"Returns",id:"returns",level:2},{value:"Example",id:"example",level:2}];function a(e){const n={a:"a",code:"code",em:"em",h2:"h2",h3:"h3",p:"p",pre:"pre",strong:"strong",...(0,c.R)(),...e.components};return(0,i.jsxs)(i.Fragment,{children:[(0,i.jsx)(n.pre,{children:(0,i.jsx)(n.code,{className:"language-ts",children:'function ZkProgram<Config, _>(config: Config & {\n  methods: { [I in string | number | symbol]: InferMethodType<Config>[I] };\n  name: string;\n  overrideWrapDomain: 0 | 2 | 1;\n }): {\n  analyzeMethods: () => Promise<{ [I in keyof Config["methods"]]: MethodAnalysis }>;\n  auxiliaryOutputTypes: InferAuxiliaryOutputs<Config>;\n  compile: (options?: {\n     cache: Cache;\n     forceRecompile: boolean;\n     proofsEnabled: boolean;\n     withRuntimeTables: boolean;\n    }) => Promise<{\n     verificationKey: {\n        data: string;\n        hash: Field;\n       };\n    }>;\n  digest: () => Promise<string>;\n  name: string;\n  privateInputTypes: InferPrivateInput<Config>;\n  Proof: typeof Proof;\n  proofsEnabled: boolean;\n  publicInputType: ProvableOrUndefined<Get<Config, "publicInput">>;\n  publicOutputType: ProvableOrVoid<Get<Config, "publicOutput">>;\n  rawMethods: { [I in keyof Config["methods"]]: InferMethodType<Config>[I]["method"] };\n  verify: (proof: Proof<InferProvableOrUndefined<Get<Config, "publicInput">>, InferProvableOrVoid<Get<Config, "publicOutput">>>) => Promise<boolean>;\n  maxProofsVerified: Promise<0 | 1 | 2>;\n  setProofsEnabled: void;\n } & { [I in keyof Config["methods"]]: Prover<InferProvableOrUndefined<Get<Config, "publicInput">>, ProvableOrUndefined<Get<Config, "publicInput">>, InferProvableOrVoid<Get<Config, "publicOutput">>, InferPrivateInput<Config>[I], InferProvableOrUndefined<InferAuxiliaryOutputs<Config>[I]>> }\n'})}),"\n",(0,i.jsxs)(n.p,{children:["Defined in: ",(0,i.jsx)(n.a,{href:"https://github.com/o1-labs/o1js/blob/df1ff77af12d7cbbed4a6167f02815fad4f0dceb/src/lib/proof-system/zkprogram.ts#L224",children:"lib/proof-system/zkprogram.ts:224"})]}),"\n",(0,i.jsxs)(n.p,{children:["Wraps config + provable code into a program capable of producing ",(0,i.jsx)(n.a,{href:"/o1js/api-reference/classes/Proof",children:"Proof"}),"s."]}),"\n",(0,i.jsx)(n.h2,{id:"type-parameters",children:"Type Parameters"}),"\n",(0,i.jsxs)(n.p,{children:["\u2022 ",(0,i.jsx)(n.strong,{children:"Config"})," ",(0,i.jsx)(n.em,{children:"extends"})," ",(0,i.jsx)(n.code,{children:"ConfigBaseType"})]}),"\n",(0,i.jsxs)(n.p,{children:["\u2022 ",(0,i.jsx)(n.strong,{children:"_"})," ",(0,i.jsx)(n.em,{children:"extends"})," ",(0,i.jsx)(n.code,{children:"unknown"})," = ",(0,i.jsx)(n.code,{children:"unknown"})]}),"\n",(0,i.jsx)(n.h2,{id:"parameters",children:"Parameters"}),"\n",(0,i.jsx)(n.h3,{id:"config",children:"config"}),"\n",(0,i.jsxs)(n.p,{children:[(0,i.jsx)(n.code,{children:"Config"})," & {\n",(0,i.jsx)(n.code,{children:"methods"}),": { [I in string | number | symbol]: InferMethodType<Config>[I] };\n",(0,i.jsx)(n.code,{children:"name"}),": ",(0,i.jsx)(n.code,{children:"string"}),";\n",(0,i.jsx)(n.code,{children:"overrideWrapDomain"}),": ",(0,i.jsx)(n.code,{children:"0"})," | ",(0,i.jsx)(n.code,{children:"2"})," | ",(0,i.jsx)(n.code,{children:"1"}),";\n}"]}),"\n",(0,i.jsx)(n.p,{children:"The configuration of the program, describing the type of the public input and public output, as well as defining the methods which can be executed provably."}),"\n",(0,i.jsx)(n.h2,{id:"returns",children:"Returns"}),"\n",(0,i.jsxs)(n.p,{children:["{\n",(0,i.jsx)(n.code,{children:"analyzeMethods"}),": () => ",(0,i.jsx)(n.code,{children:"Promise"}),"<",(0,i.jsx)(n.code,{children:'{ [I in keyof Config["methods"]]: MethodAnalysis }'}),">;\n",(0,i.jsx)(n.code,{children:"auxiliaryOutputTypes"}),": ",(0,i.jsx)(n.code,{children:"InferAuxiliaryOutputs"}),"<",(0,i.jsx)(n.code,{children:"Config"}),">;\n",(0,i.jsx)(n.code,{children:"compile"}),": (",(0,i.jsx)(n.code,{children:"options"}),"?: {\n",(0,i.jsx)(n.code,{children:"cache"}),": ",(0,i.jsx)(n.a,{href:"/o1js/api-reference/type-aliases/Cache",children:(0,i.jsx)(n.code,{children:"Cache"})}),";\n",(0,i.jsx)(n.code,{children:"forceRecompile"}),": ",(0,i.jsx)(n.code,{children:"boolean"}),";\n",(0,i.jsx)(n.code,{children:"proofsEnabled"}),": ",(0,i.jsx)(n.code,{children:"boolean"}),";\n",(0,i.jsx)(n.code,{children:"withRuntimeTables"}),": ",(0,i.jsx)(n.code,{children:"boolean"}),";\n}) => ",(0,i.jsx)(n.code,{children:"Promise"}),"<{\n",(0,i.jsx)(n.code,{children:"verificationKey"}),": {\n",(0,i.jsx)(n.code,{children:"data"}),": ",(0,i.jsx)(n.code,{children:"string"}),";\n",(0,i.jsx)(n.code,{children:"hash"}),": ",(0,i.jsx)(n.a,{href:"/o1js/api-reference/type-aliases/Field",children:(0,i.jsx)(n.code,{children:"Field"})}),";\n};\n}>;\n",(0,i.jsx)(n.code,{children:"digest"}),": () => ",(0,i.jsx)(n.code,{children:"Promise"}),"<",(0,i.jsx)(n.code,{children:"string"}),">;\n",(0,i.jsx)(n.code,{children:"name"}),": ",(0,i.jsx)(n.code,{children:"string"}),";\n",(0,i.jsx)(n.code,{children:"privateInputTypes"}),": ",(0,i.jsx)(n.code,{children:"InferPrivateInput"}),"<",(0,i.jsx)(n.code,{children:"Config"}),">;\n",(0,i.jsx)(n.code,{children:"Proof"}),": ",(0,i.jsx)(n.em,{children:"typeof"})," ",(0,i.jsx)(n.a,{href:"/o1js/api-reference/classes/Proof",children:(0,i.jsx)(n.code,{children:"Proof"})}),";\n",(0,i.jsx)(n.code,{children:"proofsEnabled"}),": ",(0,i.jsx)(n.code,{children:"boolean"}),";\n",(0,i.jsx)(n.code,{children:"publicInputType"}),": ",(0,i.jsx)(n.code,{children:"ProvableOrUndefined"}),"<",(0,i.jsx)(n.code,{children:"Get"}),"<",(0,i.jsx)(n.code,{children:"Config"}),", ",(0,i.jsx)(n.code,{children:'"publicInput"'}),">>;\n",(0,i.jsx)(n.code,{children:"publicOutputType"}),": ",(0,i.jsx)(n.code,{children:"ProvableOrVoid"}),"<",(0,i.jsx)(n.code,{children:"Get"}),"<",(0,i.jsx)(n.code,{children:"Config"}),", ",(0,i.jsx)(n.code,{children:'"publicOutput"'}),">>;\n",(0,i.jsx)(n.code,{children:"rawMethods"}),": ",(0,i.jsx)(n.code,{children:'{ [I in keyof Config["methods"]]: InferMethodType<Config>[I]["method"] }'}),";\n",(0,i.jsx)(n.code,{children:"verify"}),": (",(0,i.jsx)(n.code,{children:"proof"}),": ",(0,i.jsx)(n.a,{href:"/o1js/api-reference/classes/Proof",children:(0,i.jsx)(n.code,{children:"Proof"})}),"<",(0,i.jsx)(n.code,{children:"InferProvableOrUndefined"}),"<",(0,i.jsx)(n.code,{children:"Get"}),"<",(0,i.jsx)(n.code,{children:"Config"}),", ",(0,i.jsx)(n.code,{children:'"publicInput"'}),">>, ",(0,i.jsx)(n.code,{children:"InferProvableOrVoid"}),"<",(0,i.jsx)(n.code,{children:"Get"}),"<",(0,i.jsx)(n.code,{children:"Config"}),", ",(0,i.jsx)(n.code,{children:'"publicOutput"'}),">>>) => ",(0,i.jsx)(n.code,{children:"Promise"}),"<",(0,i.jsx)(n.code,{children:"boolean"}),">;\n",(0,i.jsx)(n.code,{children:"maxProofsVerified"}),": ",(0,i.jsx)(n.code,{children:"Promise"}),"<",(0,i.jsx)(n.code,{children:"0"})," | ",(0,i.jsx)(n.code,{children:"1"})," | ",(0,i.jsx)(n.code,{children:"2"}),">;\n",(0,i.jsx)(n.code,{children:"setProofsEnabled"}),": ",(0,i.jsx)(n.code,{children:"void"}),";\n} & ",(0,i.jsx)(n.code,{children:'{ [I in keyof Config["methods"]]: Prover<InferProvableOrUndefined<Get<Config, "publicInput">>, ProvableOrUndefined<Get<Config, "publicInput">>, InferProvableOrVoid<Get<Config, "publicOutput">>, InferPrivateInput<Config>[I], InferProvableOrUndefined<InferAuxiliaryOutputs<Config>[I]>> }'})]}),"\n",(0,i.jsx)(n.p,{children:"an object that can be used to compile, prove, and verify the program."}),"\n",(0,i.jsx)(n.h2,{id:"example",children:"Example"}),"\n",(0,i.jsx)(n.pre,{children:(0,i.jsx)(n.code,{className:"language-ts",children:"const ExampleProgram = ZkProgram({\n  name: 'ExampleProgram',\n  publicOutput: Int64,\n  methods: {\n    // Prove that I know 2 numbers less than 100 each, whose product is greater than 1000\n    provableMultiply: {\n      privateInputs: [Int64, Int64],\n      method: async (n1: Int64, n2: Int64) => {\n        n1.assertLessThan(100);\n        n2.assertLessThan(100);\n        const publicOutput = n1.mul(n2);\n        publicOutput.assertGreaterThan(1000);\n        return { publicOutput: n1.mul(n2) }\n      }\n    }\n  }\n});\n"})})]})}function h(e={}){const{wrapper:n}={...(0,c.R)(),...e.components};return n?(0,i.jsx)(n,{...e,children:(0,i.jsx)(a,{...e})}):a(e)}}}]);