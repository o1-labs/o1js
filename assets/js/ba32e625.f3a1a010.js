"use strict";(self.webpackChunkdocumentation_site=self.webpackChunkdocumentation_site||[]).push([[20533],{95676:(e,n,i)=>{i.r(n),i.d(n,{assets:()=>o,contentTitle:()=>a,default:()=>h,frontMatter:()=>l,metadata:()=>t,toc:()=>c});const t=JSON.parse('{"id":"writing-constraint-systems/conditional-logic","title":"Conditional Logic","description":"Overview","source":"@site/docs/writing-constraint-systems/conditional-logic.mdx","sourceDirName":"writing-constraint-systems","slug":"/writing-constraint-systems/conditional-logic","permalink":"/o1js/writing-constraint-systems/conditional-logic","draft":false,"unlisted":false,"editUrl":"https://github.com/docs/writing-constraint-systems/conditional-logic.mdx","tags":[],"version":"current","frontMatter":{"title":"Conditional Logic"},"sidebar":"docs","previous":{"title":"Witnesses","permalink":"/o1js/writing-constraint-systems/witnesses"},"next":{"title":"Analyzing Constraints","permalink":"/o1js/writing-constraint-systems/analyzing-constraint-systems"}}');var s=i(74848),r=i(28453);i(58069);const l={title:"Conditional Logic"},a=void 0,o={},c=[{value:"Overview",id:"overview",level:2},{value:"How Circuits Handle Control Flow",id:"how-circuits-handle-control-flow",level:2},{value:"The Two Phases of Circuits",id:"the-two-phases-of-circuits",level:2},{value:"1. Compile Time (Circuit Generation)",id:"1-compile-time-circuit-generation",level:3},{value:"Example: HMAC Key Preparation at Compile Time",id:"example-hmac-key-preparation-at-compile-time",level:4},{value:"2. Prove Time (Circuit Execution)",id:"2-prove-time-circuit-execution",level:3},{value:"Example: Value Selection Pattern",id:"example-value-selection-pattern",level:4},{value:"Example: Using Functions",id:"example-using-functions",level:4},{value:"Common Pitfall: Side Effects",id:"common-pitfall-side-effects",level:4},{value:"Summary",id:"summary",level:2}];function d(e){const n={code:"code",h2:"h2",h3:"h3",h4:"h4",li:"li",mermaid:"mermaid",ol:"ol",p:"p",pre:"pre",table:"table",tbody:"tbody",td:"td",th:"th",thead:"thead",tr:"tr",ul:"ul",...(0,r.R)(),...e.components};return(0,s.jsxs)(s.Fragment,{children:[(0,s.jsx)(n.h2,{id:"overview",children:"Overview"}),"\n",(0,s.jsxs)(n.p,{children:["In traditional programming, we use ",(0,s.jsx)(n.code,{children:"if"})," statements to control program flow by evaluating conditions and branching to different code paths. However, zero-knowledge circuits work differently - they must follow the exact same path every time they execute. This fundamental difference requires us to think about conditional logic in a different way."]}),"\n",(0,s.jsx)(n.h2,{id:"how-circuits-handle-control-flow",children:"How Circuits Handle Control Flow"}),"\n",(0,s.jsx)(n.mermaid,{value:'graph LR\n%% Compile Time section\nA["JavaScript<br/>Control Flow"] --\x3e |"Defines"| B["Circuit<br/>Layout"]\nB --\x3e |"Creates"| C["Constraint<br/>System"]\n\n%% Prove Time section\nD["Private/Public<br/>Inputs"] --\x3e E["Circuit<br/>Execution"]\nE --\x3e F["Zero-Knowledge<br/>Proof"]\n\n%% Connect sections\nC --\x3e E\n\n%% Subgraph styling\nsubgraph ct[" Compile Time "]\n    A\n    B\n    C\nend\n\nsubgraph pt[" Prove Time "]\n    D\n    E\n    F\nend'}),"\n",(0,s.jsx)(n.h2,{id:"the-two-phases-of-circuits",children:"The Two Phases of Circuits"}),"\n",(0,s.jsx)(n.h3,{id:"1-compile-time-circuit-generation",children:"1. Compile Time (Circuit Generation)"}),"\n",(0,s.jsx)(n.p,{children:"During compile time, regular JavaScript code runs to shape your circuit:"}),"\n",(0,s.jsxs)(n.ul,{children:["\n",(0,s.jsxs)(n.li,{children:["Regular JavaScript ",(0,s.jsx)(n.code,{children:"if/else"})," statements and loops are allowed"]}),"\n",(0,s.jsx)(n.li,{children:"The circuit structure is being determined"}),"\n",(0,s.jsx)(n.li,{children:"You can optimize based on known parameters"}),"\n",(0,s.jsx)(n.li,{children:"The final structure becomes fixed before proving begins"}),"\n"]}),"\n",(0,s.jsx)(n.h4,{id:"example-hmac-key-preparation-at-compile-time",children:"Example: HMAC Key Preparation at Compile Time"}),"\n",(0,s.jsx)(n.p,{children:"Here's a real-world example from the HMAC implementation that uses compile-time conditions to optimize the circuit:"}),"\n",(0,s.jsx)(n.pre,{children:(0,s.jsx)(n.code,{className:"language-ts",metastring:"file=../snippets/hmac-sha256/hmac-sha256.ts start=start_keyprep end=end_keyprep",children:"/**\n * Prepares a key for HMAC-SHA256 computation according to the HMAC specification (RFC 2104).\n *\n * If the key is longer than the block size (64 bytes):\n * - The key is first hashed using SHA-256 to produce a 32-byte key\n * - Then the 32-byte key is padded with zeros to reach the block size (64 bytes)\n *\n * If the key is shorter than the block size:\n * - The key is padded with zeros to reach the block size\n *\n * If the key is exactly the block size:\n * - The key is used as-is\n *\n * @param key - The input key as FlexibleBytes\n * @returns A standardized key of exactly BLOCK_SIZE (64) bytes\n */\nstatic prepareKey(key: FlexibleBytes): Bytes {\n  let keyBuffer = Bytes.from(key);\n\n  if (key.length > this.BLOCK_SIZE) {\n    const hashedKeyBuffer = Hash.SHA2_256.hash(key);\n    keyBuffer = Bytes.from(hashedKeyBuffer);\n  }\n\n  if (keyBuffer.length < this.BLOCK_SIZE) {\n    keyBuffer = Bytes(this.BLOCK_SIZE).from(keyBuffer.bytes);\n  }\n\n  return keyBuffer;\n}\n"})}),"\n",(0,s.jsx)(n.p,{children:"This example demonstrates how compile-time conditions affect circuit structure:"}),"\n",(0,s.jsxs)(n.table,{children:[(0,s.jsx)(n.thead,{children:(0,s.jsxs)(n.tr,{children:[(0,s.jsx)(n.th,{children:"Key Length"}),(0,s.jsx)(n.th,{children:"Message Length"}),(0,s.jsx)(n.th,{children:"Circuit Structure"}),(0,s.jsx)(n.th,{children:"Total Constraints"})]})}),(0,s.jsxs)(n.tbody,{children:[(0,s.jsxs)(n.tr,{children:[(0,s.jsx)(n.td,{children:"4 bytes"}),(0,s.jsx)(n.td,{children:"28 bytes"}),(0,s.jsx)(n.td,{children:"Padding only"}),(0,s.jsx)(n.td,{children:"21,214"})]}),(0,s.jsxs)(n.tr,{children:[(0,s.jsx)(n.td,{children:"20 bytes"}),(0,s.jsx)(n.td,{children:"8 bytes"}),(0,s.jsx)(n.td,{children:"Padding only"}),(0,s.jsx)(n.td,{children:"21,136"})]}),(0,s.jsxs)(n.tr,{children:[(0,s.jsx)(n.td,{children:"131 bytes"}),(0,s.jsx)(n.td,{children:"54 bytes"}),(0,s.jsx)(n.td,{children:"SHA-256 + padding"}),(0,s.jsx)(n.td,{children:"37,228"})]}),(0,s.jsxs)(n.tr,{children:[(0,s.jsx)(n.td,{children:"131 bytes"}),(0,s.jsx)(n.td,{children:"152 bytes"}),(0,s.jsx)(n.td,{children:"SHA-256 + padding"}),(0,s.jsx)(n.td,{children:"47,859"})]})]})]}),"\n",(0,s.jsxs)(n.p,{children:["The JavaScript ",(0,s.jsx)(n.code,{children:"if"})," statements run at compile time to determine:"]}),"\n",(0,s.jsxs)(n.ol,{children:["\n",(0,s.jsx)(n.li,{children:"Whether to include SHA-256 hashing constraints (for long keys)"}),"\n",(0,s.jsx)(n.li,{children:"Whether to include padding constraints (for short keys)"}),"\n",(0,s.jsx)(n.li,{children:"The final circuit structure and constraint count"}),"\n"]}),"\n",(0,s.jsx)(n.h3,{id:"2-prove-time-circuit-execution",children:"2. Prove Time (Circuit Execution)"}),"\n",(0,s.jsx)(n.p,{children:"During prove time, the circuit executes with actual values:"}),"\n",(0,s.jsxs)(n.ul,{children:["\n",(0,s.jsx)(n.li,{children:"Circuit structure is fixed"}),"\n",(0,s.jsx)(n.li,{children:"All paths must be evaluated"}),"\n",(0,s.jsx)(n.li,{children:"No dynamic branching is possible"}),"\n",(0,s.jsx)(n.li,{children:"Conditional logic must use special constructs"}),"\n"]}),"\n",(0,s.jsx)(n.h4,{id:"example-value-selection-pattern",children:"Example: Value Selection Pattern"}),"\n",(0,s.jsx)(n.p,{children:"Instead of using traditional if/else statements, we use value selection at prove time:"}),"\n",(0,s.jsx)(n.pre,{children:(0,s.jsx)(n.code,{className:"language-ts",metastring:"file=../snippets/conditional-logic/conditional-logic.ts start=start_valid_execution end=end_valid_execution",children:"// Out of the circuit (Field.random() cannot be used at prover time)\nconst arr = [\n  Field.random(),\n  Field.random(),\n  Field.random(),\n  Field.random(),\n  Field.random(),\n];\n// In the circuit\nlet n_heads = Field(0);\nfor (let i = 0; i < 5; i++) {\n  const x = arr[i];\n  const flip = Provable.if(x.isEven(), Field(1), Field(0));\n  n_heads = n_heads.add(flip);\n}\n"})}),"\n",(0,s.jsx)(n.p,{children:"This works because we're selecting a value rather than trying to execute different code paths. The result is determined by the condition, but both paths are still evaluated."}),"\n",(0,s.jsx)(n.h4,{id:"example-using-functions",children:"Example: Using Functions"}),"\n",(0,s.jsx)(n.p,{children:"You can use functions in conditional paths if they follow these rules:"}),"\n",(0,s.jsxs)(n.ul,{children:["\n",(0,s.jsx)(n.li,{children:"Must return the same type for all paths"}),"\n",(0,s.jsx)(n.li,{children:"No side effects allowed"}),"\n",(0,s.jsx)(n.li,{children:"Must be deterministic"}),"\n"]}),"\n",(0,s.jsx)(n.p,{children:"Here's an example:"}),"\n",(0,s.jsx)(n.pre,{children:(0,s.jsx)(n.code,{className:"language-ts",metastring:"file=../snippets/conditional-logic/conditional-logic.ts start=start_2_valid_execution_with_function end=end_2_valid_execution_with_function",children:"function oneMoreThan(x: Field) {\n  return x.add(1);\n}\n\nlet n_heads = Field(0);\nfor (let i = 0; i < 5; i++) {\n  const x = Field.random();\n  const new_n_heads = Provable.if(x.isEven(), oneMoreThan(n_heads), n_heads);\n  n_heads = new_n_heads;\n}\n"})}),"\n",(0,s.jsx)(n.h4,{id:"common-pitfall-side-effects",children:"Common Pitfall: Side Effects"}),"\n",(0,s.jsx)(n.p,{children:"Here's an example of conditional logic that won't work at prove time:"}),"\n",(0,s.jsx)(n.pre,{children:(0,s.jsx)(n.code,{className:"language-ts",metastring:"file=../snippets/conditional-logic/conditional-logic.ts start=start_invalid_execution end=end_invalid_execution",children:"// INVALID - DO NOT COPY\nlet n_heads = Field(0);\nfor (let i = 0; i < 5; i++) {\n  const x = Field.random();\n  Provable.if(\n    x.isEven(),\n    (n_heads = n_heads.add(1)),\n    (n_heads = n_heads.add(0))\n  );\n}\n// n_heads is ALWAYS 5\n"})}),"\n",(0,s.jsx)(n.p,{children:"The problem: Both paths are always evaluated, so the counter would always increment by the same amount. Side effects in conditional paths will not work as expected because both paths are always executed."}),"\n",(0,s.jsx)(n.h2,{id:"summary",children:"Summary"}),"\n",(0,s.jsx)(n.p,{children:"When writing conditional logic in o1js:"}),"\n",(0,s.jsxs)(n.ul,{children:["\n",(0,s.jsx)(n.li,{children:"Use JavaScript if/else for compile-time circuit optimization"}),"\n",(0,s.jsxs)(n.li,{children:["Use ",(0,s.jsx)(n.code,{children:"Provable.if"})," for runtime value selection"]}),"\n",(0,s.jsx)(n.li,{children:"Avoid side effects in conditional paths"}),"\n",(0,s.jsx)(n.li,{children:"Remember that both paths are always evaluated"}),"\n",(0,s.jsx)(n.li,{children:"Keep functions pure and deterministic"}),"\n"]})]})}function h(e={}){const{wrapper:n}={...(0,r.R)(),...e.components};return n?(0,s.jsx)(n,{...e,children:(0,s.jsx)(d,{...e})}):d(e)}}}]);