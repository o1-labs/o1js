"use strict";(self.webpackChunkdocumentation_site=self.webpackChunkdocumentation_site||[]).push([[36],{28453:(e,n,s)=>{s.d(n,{R:()=>t,x:()=>c});var i=s(96540);const r={},l=i.createContext(r);function t(e){const n=i.useContext(l);return i.useMemo((function(){return"function"==typeof e?e(n):{...n,...e}}),[n,e])}function c(e){let n;return n=e.disableParentContext?"function"==typeof e.components?e.components(r):e.components||r:t(e.components),i.createElement(l.Provider,{value:n},e.children)}},72803:(e,n,s)=>{s.r(n),s.d(n,{assets:()=>d,contentTitle:()=>c,default:()=>h,frontMatter:()=>t,metadata:()=>i,toc:()=>a});const i=JSON.parse('{"id":"api-reference/functions/createForeignField","title":"createForeignField","description":"Defined in622","source":"@site/docs/api-reference/functions/createForeignField.mdx","sourceDirName":"api-reference/functions","slug":"/api-reference/functions/createForeignField","permalink":"/o1js/api-reference/functions/createForeignField","draft":false,"unlisted":false,"editUrl":"https://github.com/docs/api-reference/functions/createForeignField.mdx","tags":[],"version":"current","frontMatter":{},"sidebar":"docs","previous":{"title":"createForeignCurve","permalink":"/o1js/api-reference/functions/createForeignCurve"},"next":{"title":"declareMethods","permalink":"/o1js/api-reference/functions/declareMethods"}}');var r=s(74848),l=s(28453);const t={},c=void 0,d={},a=[{value:"Parameters",id:"parameters",level:2},{value:"modulus",id:"modulus",level:3},{value:"Returns",id:"returns",level:2}];function o(e){const n={a:"a",code:"code",em:"em",h2:"h2",h3:"h3",li:"li",p:"p",pre:"pre",ul:"ul",...(0,l.R)(),...e.components};return(0,r.jsxs)(r.Fragment,{children:[(0,r.jsx)(n.pre,{children:(0,r.jsx)(n.code,{className:"language-ts",children:"function createForeignField(modulus: bigint): typeof UnreducedForeignField\n"})}),"\n",(0,r.jsxs)(n.p,{children:["Defined in: ",(0,r.jsx)(n.a,{href:"https://github.com/o1-labs/o1js/blob/df1ff77af12d7cbbed4a6167f02815fad4f0dceb/src/lib/provable/foreign-field.ts#L622",children:"lib/provable/foreign-field.ts:622"})]}),"\n",(0,r.jsxs)(n.p,{children:["Create a class representing a prime order finite field, which is different from the native ",(0,r.jsx)(n.a,{href:"/o1js/api-reference/classes/Field",children:"Field"}),"."]}),"\n",(0,r.jsx)(n.pre,{children:(0,r.jsx)(n.code,{className:"language-ts",children:"const SmallField = createForeignField(17n); // the finite field F_17\n"})}),"\n",(0,r.jsxs)(n.p,{children:[(0,r.jsx)(n.code,{children:"createForeignField(p)"})," takes the prime modulus ",(0,r.jsx)(n.code,{children:"p"})," of the finite field as input, as a bigint.\nWe support prime moduli up to a size of 259 bits."]}),"\n",(0,r.jsxs)(n.p,{children:["The returned ",(0,r.jsx)(n.a,{href:"/o1js/api-reference/classes/ForeignField",children:"ForeignField"})," class supports arithmetic modulo ",(0,r.jsx)(n.code,{children:"p"})," (addition and multiplication),\nas well as helper methods like ",(0,r.jsx)(n.code,{children:"assertEquals()"})," and ",(0,r.jsx)(n.code,{children:"equals()"}),"."]}),"\n",(0,r.jsx)(n.p,{children:(0,r.jsx)(n.em,{children:"Advanced details:"})}),"\n",(0,r.jsx)(n.p,{children:"Internally, a foreign field element is represented as three native field elements, each of which\nrepresents a limb of 88 bits. Therefore, being a valid foreign field element means that all 3 limbs\nfit in 88 bits, and the foreign field element altogether is smaller than the modulus p."}),"\n",(0,r.jsxs)(n.p,{children:["Since the full ",(0,r.jsx)(n.code,{children:"x < p"})," check is expensive, by default we only prove a weaker assertion, ",(0,r.jsx)(n.code,{children:"x < 2^ceil(log2(p))"}),",\nsee ",(0,r.jsx)(n.a,{href:"/o1js/api-reference/classes/ForeignField#assertalmostreduced-2",children:"ForeignField.assertAlmostReduced"})," for more details."]}),"\n",(0,r.jsxs)(n.p,{children:['This weaker assumption is what we call "almost reduced", and it is represented by the ',(0,r.jsx)(n.a,{href:"/o1js/api-reference/classes/AlmostForeignField",children:"AlmostForeignField"})," class.\nNote that only ",(0,r.jsx)(n.a,{href:"/o1js/api-reference/classes/AlmostForeignField",children:"AlmostForeignField"})," supports multiplication and inversion, while ",(0,r.jsx)(n.a,{href:"/o1js/api-reference/classes/UnreducedForeignField",children:"UnreducedForeignField"}),"\nonly supports addition and subtraction."]}),"\n",(0,r.jsxs)(n.p,{children:["This function returns the ",(0,r.jsx)(n.code,{children:"Unreduced"})," class, which will cause the minimum amount of range checks to be created by default.\nIf you want to do multiplication, you have two options:"]}),"\n",(0,r.jsxs)(n.ul,{children:["\n",(0,r.jsxs)(n.li,{children:["create your field elements using the ",(0,r.jsx)(n.a,{href:"/o1js/api-reference/classes/ForeignField#almostreduced",children:"ForeignField.AlmostReduced"})," constructor."]}),"\n"]}),"\n",(0,r.jsx)(n.pre,{children:(0,r.jsx)(n.code,{className:"language-ts",children:"let x = Provable.witness(ForeignField.AlmostReduced, () => 5n);\n"})}),"\n",(0,r.jsxs)(n.ul,{children:["\n",(0,r.jsxs)(n.li,{children:["create your field elements normally and convert them using ",(0,r.jsx)(n.code,{children:"x.assertAlmostReduced()"}),"."]}),"\n"]}),"\n",(0,r.jsx)(n.pre,{children:(0,r.jsx)(n.code,{className:"language-ts",children:"let xChecked = x.assertAlmostReduced(); // asserts x < 2^ceil(log2(p)); returns `AlmostForeignField`\n"})}),"\n",(0,r.jsxs)(n.p,{children:["Similarly, there is a separate class ",(0,r.jsx)(n.a,{href:"/o1js/api-reference/classes/CanonicalForeignField",children:"CanonicalForeignField"}),' which represents fully reduced, "canonical" field elements.\nTo convert to a canonical field element, use ',(0,r.jsx)(n.code,{children:"ForeignField.assertCanonical()"}),":"]}),"\n",(0,r.jsx)(n.pre,{children:(0,r.jsx)(n.code,{className:"language-ts",children:"x.assertCanonical(); // asserts x < p; returns `CanonicalForeignField`\n"})}),"\n",(0,r.jsx)(n.p,{children:"You will likely not need canonical fields most of the time."}),"\n",(0,r.jsxs)(n.p,{children:["Base types for all of these classes are separately exported as ",(0,r.jsx)(n.a,{href:"/o1js/api-reference/classes/UnreducedForeignField",children:"UnreducedForeignField"}),", ",(0,r.jsx)(n.a,{href:"/o1js/api-reference/classes/AlmostForeignField",children:"AlmostForeignField"})," and ",(0,r.jsx)(n.a,{href:"/o1js/api-reference/classes/CanonicalForeignField",children:"CanonicalForeignField"}),".,"]}),"\n",(0,r.jsx)(n.h2,{id:"parameters",children:"Parameters"}),"\n",(0,r.jsx)(n.h3,{id:"modulus",children:"modulus"}),"\n",(0,r.jsx)(n.p,{children:(0,r.jsx)(n.code,{children:"bigint"})}),"\n",(0,r.jsx)(n.p,{children:"the modulus of the finite field you are instantiating"}),"\n",(0,r.jsx)(n.h2,{id:"returns",children:"Returns"}),"\n",(0,r.jsxs)(n.p,{children:[(0,r.jsx)(n.em,{children:"typeof"})," ",(0,r.jsx)(n.a,{href:"/o1js/api-reference/classes/UnreducedForeignField",children:(0,r.jsx)(n.code,{children:"UnreducedForeignField"})})]})]})}function h(e={}){const{wrapper:n}={...(0,l.R)(),...e.components};return n?(0,r.jsx)(n,{...e,children:(0,r.jsx)(o,{...e})}):o(e)}}}]);