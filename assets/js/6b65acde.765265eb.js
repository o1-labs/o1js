"use strict";(self.webpackChunkdocumentation_site=self.webpackChunkdocumentation_site||[]).push([[38561],{22806:(e,a,t)=>{t.r(a),t.d(a,{assets:()=>l,contentTitle:()=>r,default:()=>c,frontMatter:()=>o,metadata:()=>n,toc:()=>d});const n=JSON.parse('{"id":"advanced-concepts/sideloaded-vks","title":"Sideloaded Verification Keys","description":"In the article on recursion, we showed how o1js can be used to","source":"@site/docs/advanced-concepts/sideloaded-vks.mdx","sourceDirName":"advanced-concepts","slug":"/advanced-concepts/sideloaded-vks","permalink":"/o1js/advanced-concepts/sideloaded-vks","draft":false,"unlisted":false,"editUrl":"https://github.com/docs/advanced-concepts/sideloaded-vks.mdx","tags":[],"version":"current","frontMatter":{"title":"Sideloaded Verification Keys","sidebar_label":"Sideloading"},"sidebar":"docs","previous":{"title":"Recursion","permalink":"/o1js/advanced-concepts/recursion"},"next":{"title":"Understanding the Algorithm","permalink":"/o1js/tutorials/hmac/hmac-basics"}}');var s=t(74848),i=t(28453);const o={title:"Sideloaded Verification Keys",sidebar_label:"Sideloading"},r=void 0,l={},d=[{value:"Multiple Hash Example",id:"multiple-hash-example",level:2},{value:"Setup",id:"setup",level:3},{value:"Defining a Sideloaded Proof",id:"defining-a-sideloaded-proof",level:3},{value:"Using the Sideloaded Proof in a ZkProgram",id:"using-the-sideloaded-proof-in-a-zkprogram",level:3},{value:"Instantiation and Verifying the Wrap Proof",id:"instantiation-and-verifying-the-wrap-proof",level:3}];function h(e){const a={a:"a",admonition:"admonition",code:"code",em:"em",h2:"h2",h3:"h3",li:"li",p:"p",pre:"pre",ul:"ul",...(0,i.R)(),...e.components};return(0,s.jsxs)(s.Fragment,{children:[(0,s.jsxs)(a.p,{children:["In the article on ",(0,s.jsx)(a.a,{href:"/o1js/advanced-concepts/recursion",children:"recursion"}),", we showed how o1js can be used to\nwrite constraint systems that verify other constraint systems.  Those examples always assumed that the\nprover has compiled an instance of the other ",(0,s.jsx)(a.code,{children:"ZkProgram"}),".  We can, in fact, go even more general than that.\nWith sideloading, we can verify any proof, given that its shape (public inputs and outputs) are known at\ncompile time, and the verification key is available at runtime."]}),"\n",(0,s.jsx)(a.p,{children:"The use cases for sideloading include:"}),"\n",(0,s.jsxs)(a.ul,{children:["\n",(0,s.jsx)(a.li,{children:"Upgradability: Without needing to recompile the entire program (breaking compatibility with existing\nproofs), you can write your program with sideloading from the start, to support future use cases."}),"\n",(0,s.jsx)(a.li,{children:"Flexibility: You can write programs that are compatible with several proofs without enumerating them\nindividually.  (Remember that without conditional execution, it's not possible to write a big switch\nstatement to handle different proof types.  So sideloading can be an effective way to streamline an\napp)."}),"\n"]}),"\n",(0,s.jsx)(a.h2,{id:"multiple-hash-example",children:"Multiple Hash Example"}),"\n",(0,s.jsx)(a.p,{children:"Let's say we have an application with multiple hashing algorithms in use.  We want to write a simple Zk\nProgram to verify that a user knows the preimage of a hash, but we want to support any of our\nalgorithms.  Let's solve this by writing a specific program for each algorithm, and a wrapper program\nthat verifies any of them."}),"\n",(0,s.jsx)(a.h3,{id:"setup",children:"Setup"}),"\n",(0,s.jsx)(a.p,{children:"First, let's set up a Bytes32 class and some different hash function proofs.  Note that all proofs must\nhave the same shape."}),"\n",(0,s.jsx)(a.pre,{children:(0,s.jsx)(a.code,{className:"language-ts",metastring:"file=../snippets/sideloaded-vks/sideloaded-vks.ts start=start_multi_hash_setup end=end_multi_hash_setup",children:'// Define our bytes input\nclass Bytes32 extends Bytes(32) {\n  static assertEquals(a: Bytes, b: Bytes) {\n    Poseidon.hash(a.toFields()).assertEquals(Poseidon.hash(b.toFields()));\n  }\n}\n\nconst Sha2 = ZkProgram({\n  name: "SHA2_256",\n  publicInput: Bytes32,\n  methods: {\n    verifyPreimage: {\n      privateInputs: [Bytes32],\n      method: async (claimedHash: Bytes32, preimage: Bytes32) => {\n        const calculatedHash = Hash.SHA2_256.hash(preimage);\n        Bytes32.assertEquals(claimedHash, calculatedHash);\n      },\n    },\n  },\n});\n\nconst Sha3 = ZkProgram({\n  name: "SHA3_256",\n  publicInput: Bytes32,\n  methods: {\n    verifyPreimage: {\n      privateInputs: [Bytes32],\n      method: async (claimedHash: Bytes32, preimage: Bytes32) => {\n        const calculatedHash = Hash.SHA3_256.hash(preimage);\n        Bytes32.assertEquals(claimedHash, calculatedHash);\n      },\n    },\n  },\n});\n'})}),"\n",(0,s.jsx)(a.h3,{id:"defining-a-sideloaded-proof",children:"Defining a Sideloaded Proof"}),"\n",(0,s.jsxs)(a.p,{children:["Usually, a ",(0,s.jsx)(a.code,{children:"ZkProgram"}),"'s proof type is inferrable, but since we want to sideload one of several proofs, we\nneed to define the proof class explicitly."]}),"\n",(0,s.jsx)(a.pre,{children:(0,s.jsx)(a.code,{className:"language-ts",metastring:"file=../snippets/sideloaded-vks/sideloaded-vks.ts start=start_multi_hash_proof end=end_multi_hash_proof",children:"// Define the proof shape that both hash implementations satisfy\nclass HashProof extends DynamicProof<Bytes32, null> {\n  /**\n   * Bytes.provable is a little trick to access the provable type of the class - Not required for simpler types like Field or UInt32\n   */\n  static publicInputType = Bytes32.provable;\n  /**\n   * Hacky way to set the public output type to null\n   */\n  static publicOutputType = Sha2.publicOutputType;\n  /**\n   * maxProofsVerified sets the wrapping domain for this proof.\n   * Essentially, it tells the compiler how many times `verify` may be called\n   */\n  static maxProofsVerified = 0 as const;\n  /**\n   * Set all feature flags to maybe to indicate that the sideloaded proof may use any gate types\n   * NOTE: Failing to do this may result in a nasty error - unless you specifically want to exclude a feature, allMaybe is a safe default\n   */\n  static featureFlags = FeatureFlags.allMaybe;\n}\n"})}),"\n",(0,s.jsxs)(a.p,{children:["For more details on ",(0,s.jsx)(a.code,{children:"DynamicProof"})," and ",(0,s.jsx)(a.code,{children:"FeatureFlags"}),", check out the api reference: ",(0,s.jsx)(a.a,{href:"/o1js/api-reference/classes/DynamicProof",children:"DynamicProof"}),", ",(0,s.jsx)(a.a,{href:"/o1js/api-reference/variables/FeatureFlags",children:"FeatureFlags"}),"."]}),"\n",(0,s.jsx)(a.h3,{id:"using-the-sideloaded-proof-in-a-zkprogram",children:"Using the Sideloaded Proof in a ZkProgram"}),"\n",(0,s.jsxs)(a.p,{children:["Now that we've defined the proof class, we can use it in a ",(0,s.jsx)(a.code,{children:"ZkProgram"}),"."]}),"\n",(0,s.jsx)(a.admonition,{type:"warning",children:(0,s.jsxs)(a.p,{children:["Pay attention to the constraints on the verification key.  Without these, ",(0,s.jsx)(a.em,{children:"any"})," valid proof can be sideloaded.\nWe want the flexibility of sideloading, but we need to be mindful of the security implications!"]})}),"\n",(0,s.jsx)(a.pre,{children:(0,s.jsx)(a.code,{className:"language-ts",metastring:"file=../snippets/sideloaded-vks/sideloaded-vks.ts start=start_multi_hash_program end=end_multi_hash_program",children:'// Define our generic multi-hash program\nconst MultiHash = ZkProgram({\n  name: "MultiHash",\n  publicInput: Bytes32,\n  methods: {\n    verifyPreimage: {\n      privateInputs: [HashProof, VerificationKey],\n      method: async (\n        claimedHash: Bytes32,\n        proof: HashProof,\n        verificationKey: VerificationKey\n      ) => {\n        // Pass verification key into `proof.verify` in the sideloaded case\n        proof.verify(verificationKey);\n\n        // Assert that the verification key matches one of our known programs\n        // NOTE: A merkle map could be a more efficient check for larger sets\n        // but this example uses a simpler check for clarity\n        let match = Bool(false);\n        match = match.or(\n          // SHA2_256 VK\n          verificationKey.hash.equals(\n            "18946629726997484436154648354739477208964589603707310554296950898554384176434"\n          )\n        );\n        match = match.or(\n          // SHA3_256 VK\n          verificationKey.hash.equals(\n            "10594931916390393299319985652348439891528773201960631586652037259274667432468"\n          )\n        );\n        match.assertEquals(true, "Invalid verification key");\n\n        // Now we know that the proof is legitimate\n        // The user provided proof that they know the preimage of _some_ hash\n        // Finally, let\'s confirm that _some_ hash is the hash being claimed\n        Bytes32.assertEquals(proof.publicInput, claimedHash);\n      },\n    },\n  },\n});\n'})}),"\n",(0,s.jsx)(a.h3,{id:"instantiation-and-verifying-the-wrap-proof",children:"Instantiation and Verifying the Wrap Proof"}),"\n",(0,s.jsx)(a.p,{children:"Finally, here is how you can instantiate a sideloaded proof and pass it as a parameter to the wrap\nprogram."}),"\n",(0,s.jsx)(a.pre,{children:(0,s.jsx)(a.code,{className:"language-ts",metastring:"file=../snippets/sideloaded-vks/sideloaded-vks.ts start=start_multi_hash_verify end=end_multi_hash_verify",children:"const preimage = Bytes32.random();\nconst sha2Hash = Hash.SHA2_256.hash(preimage);\nconst sha3Hash = Hash.SHA3_256.hash(preimage);\n\nconst sha2Proof = await Sha2.verifyPreimage(sha2Hash, preimage);\nconst sha3Proof = await Sha3.verifyPreimage(sha3Hash, preimage);\n\n// Wrap the original proof in the dymamic proof class for compatibility\nconst sha2ProofToBeSideloaded = HashProof.fromProof(sha2Proof.proof);\nconst sha3ProofToBeSideloaded = HashProof.fromProof(sha3Proof.proof);\n\nawait MultiHash.compile();\nconst genericProofSha2 = await MultiHash.verifyPreimage(\n  sha2Hash,\n  sha2ProofToBeSideloaded,\n  Sha2VK.verificationKey\n);\nconst genericProofSha3 = await MultiHash.verifyPreimage(\n  sha3Hash,\n  sha3ProofToBeSideloaded,\n  Sha3VK.verificationKey\n);\n\n"})})]})}function c(e={}){const{wrapper:a}={...(0,i.R)(),...e.components};return a?(0,s.jsx)(a,{...e,children:(0,s.jsx)(h,{...e})}):h(e)}},28453:(e,a,t)=>{t.d(a,{R:()=>o,x:()=>r});var n=t(96540);const s={},i=n.createContext(s);function o(e){const a=n.useContext(i);return n.useMemo((function(){return"function"==typeof e?e(a):{...a,...e}}),[a,e])}function r(e){let a;return a=e.disableParentContext?"function"==typeof e.components?e.components(s):e.components||s:o(e.components),n.createElement(i.Provider,{value:a},e.children)}}}]);