"use strict";(self.webpackChunkdocumentation_site=self.webpackChunkdocumentation_site||[]).push([[17903],{77083:(e,t,n)=>{n.r(t),n.d(t,{assets:()=>l,contentTitle:()=>r,default:()=>m,frontMatter:()=>s,metadata:()=>i,toc:()=>c});const i=JSON.parse('{"id":"getting-started/what-is-a-zk-constraint-system","title":"What is a ZK Constraint System?","description":"In order to write effective o1js, you need to understand at least the basics of ZK constraint","source":"@site/versioned_docs/version-2.4.0/getting-started/what-is-a-zk-constraint-system.mdx","sourceDirName":"getting-started","slug":"/getting-started/what-is-a-zk-constraint-system","permalink":"/o1js/2.4.0/getting-started/what-is-a-zk-constraint-system","draft":false,"unlisted":false,"editUrl":"https://github.com/versioned_docs/version-2.4.0/getting-started/what-is-a-zk-constraint-system.mdx","tags":[],"version":"2.4.0","frontMatter":{"title":"What is a ZK Constraint System?"},"sidebar":"docs","previous":{"title":"Welcome","permalink":"/o1js/2.4.0/"},"next":{"title":"Field","permalink":"/o1js/2.4.0/basic-types/field"}}');var o=n(74848),a=n(28453);n(58069);const s={title:"What is a ZK Constraint System?"},r=void 0,l={},c=[{value:"Implications for Developers",id:"implications-for-developers",level:2},{value:"No Dynamic Programming",id:"no-dynamic-programming",level:3},{value:"No Conditional Execution",id:"no-conditional-execution",level:3},{value:"Rule of Thumb: Prove the Smallest Thing",id:"rule-of-thumb-prove-the-smallest-thing",level:3}];function h(e){const t={a:"a",code:"code",em:"em",h2:"h2",h3:"h3",p:"p",pre:"pre",...(0,a.R)(),...e.components};return(0,o.jsxs)(o.Fragment,{children:[(0,o.jsx)(t.p,{children:"In order to write effective o1js, you need to understand at least the basics of ZK constraint\nsystems.  If you're coming from a background in web2 or web3, you should try to get a sense\nfor the fundamental differences between zk programming and programming for a VM before\ngetting deep into working with o1js.  If you're coming from a background writing circuits\nwith other DSLs, then this article may be just a refresher!"}),"\n",(0,o.jsx)(t.p,{children:"You can think of a constraint system as an array of gates.  Each gate is a simple math problem\nthat the prover knows how to verifiably compute that accepts some coefficients as input and\npasses along some output to the next gate.  As a mental model, you can think of gates in a\nproof system like instructions on a CPU.  A constraint system, then, is like a program that\nis composed of a list of instructions to execute in order."}),"\n",(0,o.jsxs)(t.p,{children:["Don't take the metaphor too far!  Proof systems don't operate over binary data like a CPU does,\nand they don't have an analogous gate to ",(0,o.jsx)(t.code,{children:"JUMP"})," or ",(0,o.jsx)(t.code,{children:"GOTO"}),", which means that conditional\nexecution is not supported."]}),"\n",(0,o.jsx)(t.p,{children:"TODO: We could use an illustration here too"}),"\n",(0,o.jsxs)(t.p,{children:["Currently, o1js is compatible with the Kimchi proof backend, which is specified in the\n",(0,o.jsx)(t.a,{href:"https://o1-labs.github.io/proof-systems/specs/kimchi.html",children:"Mina Book"}),"."]}),"\n",(0,o.jsx)(t.h2,{id:"implications-for-developers",children:"Implications for Developers"}),"\n",(0,o.jsx)(t.p,{children:"There are two important implications that effect almost every ZK developer.  Before getting\ninto code examples, you should be thinking about how this programming paradigm will change\nthe way you think about your code."}),"\n",(0,o.jsx)(t.h3,{id:"no-dynamic-programming",children:"No Dynamic Programming"}),"\n",(0,o.jsx)(t.p,{children:'When writing o1js, a common pattern is to "compile" a constraint system, then generate a proof\nwith the compiled artifact.  We call the time while the constraint system is being built for\nthe first time "compile time", and the time when the proof is being generated against that\nartifact "prover time".'}),"\n",(0,o.jsxs)(t.p,{children:["At compile time, and at prover time, the constraint system needs to be identical.  So if you\nconsider a common tool in programming, a dynamic loop, it won't work in ZK.  When you compile\nthe circuit, a dummy value will be used for the variables, and it will follow some execution\npath.  Then all subsequent calls to the function must follow ",(0,o.jsx)(t.em,{children:"exactly"})," the same path.  That\nmeans different values of a variable can't result in different numbers of iterations over a\nloop."]}),"\n",(0,o.jsx)(t.p,{children:"There are workarounds for this.  For instance, you can write constraint systems that execute\na single step, and call the prover function a dynamic number of times.  Or you can execute a\nloop a fixed number of times, but with some dummy behavior.  Consider this normal Javascript\ncode:"}),"\n",(0,o.jsx)(t.pre,{children:(0,o.jsx)(t.code,{className:"language-ts",children:"function multiplyAll(arr: number[]) {\n    let result = 1;\n    for (let i = 0; i < arr.length; i++) {\n        result *= arr[i];\n    }\n    return result;\n}\n"})}),"\n",(0,o.jsx)(t.p,{children:'The function isn\'t "ZK friendly" because the number of iterations over the loop is dynamic.\nTo re-imagine this function for ZK, we can fix the size of the array, and fill the rest of\nthe array with ones, which will not affect the result of the multiplication:'}),"\n",(0,o.jsx)(t.pre,{children:(0,o.jsx)(t.code,{className:"language-ts",children:"function multiplyAll(arr: number[]) {\n    let result = 1;\n    for (let i = 0; i < 10; i++) {\n        result *= arr[i] || 1;\n    }\n    return result;\n}\n"})}),"\n",(0,o.jsxs)(t.p,{children:["This way, the function will always iterate 10 times, and for any input of less than or equal\nto ten elements, the result will be the same.  Note that for arrays larger than ten, the\nresult will ",(0,o.jsx)(t.em,{children:"not"})," be the same.  You must carefully write your constraint systems to be\ncompatible with your domain."]}),"\n",(0,o.jsx)(t.h3,{id:"no-conditional-execution",children:"No Conditional Execution"}),"\n",(0,o.jsxs)(t.p,{children:["Along the same lines, a function can't execute a different code path based on the value of a\nvariable.  There are ways to conditionally assign values to variables (see:\n",(0,o.jsx)(t.a,{href:"/o1js/writing-constraint-systems/conditional-logic",children:"Conditional Logic"}),"), but the\nexecution path must always be identical."]}),"\n",(0,o.jsx)(t.h3,{id:"rule-of-thumb-prove-the-smallest-thing",children:"Rule of Thumb: Prove the Smallest Thing"}),"\n",(0,o.jsx)(t.p,{children:"A programming language with no dynamic programming and no conditional execution may sound\nuseless at first, but you don't need to write your entire application in ZK.  ZK is a spice\nthat you can use sparingly to supercharge your application.  When you specifically need to\nprove something for privacy, scale, or security, you can write a constraint system to\nmodel the problem you want to solve.  What's amazing about o1js is that you can expose that\nconstraint system system directly to users in a browser, or to a service that can access\nnode.  Design apps that use constraint systems with as little scope as possible to maximize\nperformance and developer experience."})]})}function m(e={}){const{wrapper:t}={...(0,a.R)(),...e.components};return t?(0,o.jsx)(t,{...e,children:(0,o.jsx)(h,{...e})}):h(e)}}}]);