"use strict";(self.webpackChunkdocumentation_site=self.webpackChunkdocumentation_site||[]).push([[64636],{2807:(e,s,a)=>{a.r(s),a.d(s,{assets:()=>d,contentTitle:()=>c,default:()=>o,frontMatter:()=>i,metadata:()=>t,toc:()=>u});const t=JSON.parse('{"id":"basic-types/keypairs-and-signatures","title":"Keypairs and Signatures","description":"Native Signatures","source":"@site/docs/basic-types/keypairs-and-signatures.mdx","sourceDirName":"basic-types","slug":"/basic-types/keypairs-and-signatures","permalink":"/o1js/basic-types/keypairs-and-signatures","draft":false,"unlisted":false,"editUrl":"https://github.com/docs/basic-types/keypairs-and-signatures.mdx","tags":[],"version":"current","frontMatter":{"title":"Keypairs and Signatures"},"sidebar":"docs","previous":{"title":"Integers","permalink":"/o1js/basic-types/int"},"next":{"title":"Merkle Trees","permalink":"/o1js/basic-types/merkle-trees"}}');var r=a(74848),n=a(28453);a(58069);const i={title:"Keypairs and Signatures"},c=void 0,d={},u=[{value:"Native Signatures",id:"native-signatures",level:3},{value:"ECDSA Signatures (Ethereum)",id:"ecdsa-signatures-ethereum",level:3}];function l(e){const s={a:"a",code:"code",h3:"h3",p:"p",pre:"pre",...(0,n.R)(),...e.components};return(0,r.jsxs)(r.Fragment,{children:[(0,r.jsx)(s.h3,{id:"native-signatures",children:"Native Signatures"}),"\n",(0,r.jsxs)(s.p,{children:["The ",(0,r.jsx)(s.code,{children:"Signature"})," class in o1js refers to a Schnorr signature over the Pallas curve.  It works with the ",(0,r.jsx)(s.code,{children:"PrivateKey"})," and ",(0,r.jsx)(s.code,{children:"PublicKey"})," classes to\nsign and verify messages of ",(0,r.jsx)(s.a,{href:"/o1js/basic-types/field",children:"Field"})," arrays."]}),"\n",(0,r.jsx)(s.pre,{children:(0,r.jsx)(s.code,{className:"language-ts",metastring:"file=../snippets/keypairs-and-signatures/keypairs-and-signatures.ts start=start_native_signature end=end_native_signature",children:'const privateKey = PrivateKey.random();\nconst publicKey = privateKey.toPublicKey();\nconst message = CircuitString.fromString("Hello World!").values.map((char) =>\n  char.toField()\n);\nconst signature = Signature.create(privateKey, message);\nsignature.verify(publicKey, message);\n'})}),"\n",(0,r.jsx)(s.h3,{id:"ecdsa-signatures-ethereum",children:"ECDSA Signatures (Ethereum)"}),"\n",(0,r.jsx)(s.p,{children:"ECDSA signatures are supported as well.  In general, elliptic curve cryptography is supported over foreign curves, but you can\nfollow the snippet below for verifying signatures specifically for an Ethereum configuration."}),"\n",(0,r.jsx)(s.pre,{children:(0,r.jsx)(s.code,{className:"language-ts",metastring:"file=../snippets/keypairs-and-signatures/keypairs-and-signatures.ts start=start_ethereum_signature end=end_ethereum_signature",children:'class Secp256k1 extends createForeignCurve(Crypto.CurveParams.Secp256k1) {}\nclass Ecdsa extends createEcdsa(Secp256k1) {}\nclass Bytes32 extends Bytes(32) {}\n\nconst messageEth = "Secrets hidden, truth in ZKPs ;)";\n\n// compressed public key generated by ethers.js\nconst publicKeyEth = Secp256k1.fromEthers(\n  "0x020957928494c38660d254dc03ba78f091a4aea0270afb447f193c4daf6648f02b"\n);\n\n// ECDSA signature generated by ethers.js\nconst signatureEth = Ecdsa.fromHex(\n  "0x6fada464c3bc2ae127f8c907c0c4bccbd05ba83a584156edb808b7400346b4c9558598d9c7869f5fd75d81128711f6621e4cb5ba2f52a2a51c46c859f49a833a1b"\n);\nconst msgBytes = Bytes32.fromString(messageEth);\n\nsignatureEth.verifyEthers(msgBytes, publicKeyEth);\n'})}),"\n",(0,r.jsxs)(s.p,{children:["Read more at the language reference: ",(0,r.jsx)(s.a,{href:"/o1js/api-reference/classes/Signature",children:"Signature"}),", ",(0,r.jsx)(s.a,{href:"/o1js/api-reference/classes/PrivateKey",children:"PrivateKey"}),", ",(0,r.jsx)(s.a,{href:"/o1js/api-reference/classes/PublicKey",children:"PublicKey"}),", ",(0,r.jsx)(s.a,{href:"/o1js/api-reference/functions/createEcdsa",children:"createEcdsa"}),"."]})]})}function o(e={}){const{wrapper:s}={...(0,n.R)(),...e.components};return s?(0,r.jsx)(s,{...e,children:(0,r.jsx)(l,{...e})}):l(e)}}}]);