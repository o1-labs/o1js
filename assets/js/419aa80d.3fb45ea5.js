"use strict";(self.webpackChunkdocumentation_site=self.webpackChunkdocumentation_site||[]).push([[20163],{28453:(e,n,i)=>{i.d(n,{R:()=>a,x:()=>o});var s=i(96540);const t={},r=s.createContext(t);function a(e){const n=s.useContext(r);return s.useMemo((function(){return"function"==typeof e?e(n):{...n,...e}}),[n,e])}function o(e){let n;return n=e.disableParentContext?"function"==typeof e.components?e.components(t):e.components||t:a(e.components),s.createElement(r.Provider,{value:n},e.children)}},73081:(e,n,i)=>{i.r(n),i.d(n,{assets:()=>l,contentTitle:()=>o,default:()=>u,frontMatter:()=>a,metadata:()=>s,toc:()=>c});const s=JSON.parse('{"id":"api-reference/namespaces/Experimental/functions/createProvableBigInt","title":"createProvableBigInt","description":"Defined in166","source":"@site/versioned_docs/version-2.4.0/api-reference/namespaces/Experimental/functions/createProvableBigInt.mdx","sourceDirName":"api-reference/namespaces/Experimental/functions","slug":"/api-reference/namespaces/Experimental/functions/createProvableBigInt","permalink":"/o1js/2.4.0/api-reference/namespaces/Experimental/functions/createProvableBigInt","draft":false,"unlisted":false,"editUrl":"https://github.com/versioned_docs/version-2.4.0/api-reference/namespaces/Experimental/functions/createProvableBigInt.mdx","tags":[],"version":"2.4.0","frontMatter":{},"sidebar":"docs","previous":{"title":"Recursive","permalink":"/o1js/2.4.0/api-reference/namespaces/Experimental/functions/Recursive"},"next":{"title":"memoizeWitness","permalink":"/o1js/2.4.0/api-reference/namespaces/Experimental/functions/memoizeWitness"}}');var t=i(74848),r=i(28453);const a={},o=void 0,l={},c=[{value:"Parameters",id:"parameters",level:2},{value:"modulus",id:"modulus",level:3},{value:"config?",id:"config",level:3},{value:"Returns",id:"returns",level:2},{value:"Example",id:"example",level:2},{value:"Throws",id:"throws",level:2}];function d(e){const n={a:"a",code:"code",em:"em",h2:"h2",h3:"h3",li:"li",p:"p",pre:"pre",ul:"ul",...(0,r.R)(),...e.components};return(0,t.jsxs)(t.Fragment,{children:[(0,t.jsx)(n.pre,{children:(0,t.jsx)(n.code,{className:"language-ts",children:"function createProvableBigInt(modulus: bigint, config?: BigIntParameter): typeof ProvableBigInt_\n"})}),"\n",(0,t.jsxs)(n.p,{children:["Defined in: ",(0,t.jsx)(n.a,{href:"https://github.com/o1-labs/o1js/blob/df1ff77af12d7cbbed4a6167f02815fad4f0dceb/src/index.ts#L166",children:"index.ts:166"})]}),"\n",(0,t.jsx)(n.p,{children:"Creates a class representing a ProvableBigInt with modular arithmetic capabilities.\nThis is particularly useful for implementing prime fields that don't fit into the native field."}),"\n",(0,t.jsx)(n.pre,{children:(0,t.jsx)(n.code,{className:"language-ts",children:"const BigInt521 = createProvableBigInt(2n ** 521n - 1n); // creates a class for 521-bit integers\n"})}),"\n",(0,t.jsxs)(n.p,{children:[(0,t.jsx)(n.code,{children:"createProvableBigInt(modulus, config?)"})," takes two parameters:"]}),"\n",(0,t.jsxs)(n.ul,{children:["\n",(0,t.jsxs)(n.li,{children:[(0,t.jsx)(n.code,{children:"modulus"}),": The modulus of the field (must be a prime)"]}),"\n",(0,t.jsxs)(n.li,{children:[(0,t.jsx)(n.code,{children:"config"}),": Optional configuration for custom limb size and numbers"]}),"\n"]}),"\n",(0,t.jsx)(n.p,{children:"The returned class supports comprehensive arithmetic operations including:"}),"\n",(0,t.jsxs)(n.ul,{children:["\n",(0,t.jsx)(n.li,{children:"Basic operations: addition, double, subtraction, multiplication, square, division"}),"\n",(0,t.jsx)(n.li,{children:"Advanced operations: inverse, negate, sqrt, power"}),"\n",(0,t.jsx)(n.li,{children:"Comparison operations: equals, assertEquals, greaterThan, lessthan, greaterThanOrEqual, lessThanOrEqual"}),"\n",(0,t.jsx)(n.li,{children:"Conversion methods: fromBigInt, toBigInt, fromFields, toFields, fromBits, toBits"}),"\n"]}),"\n",(0,t.jsx)(n.p,{children:"Implementation details:"}),"\n",(0,t.jsx)(n.p,{children:"Internally, a ProvableBigInt is represented as an array of Field elements (limbs),\nwhere each limb holds 116 bits as default. The total size is determined by the configuration,\nwith preset options supporting different bit lengths:"}),"\n",(0,t.jsxs)(n.ul,{children:["\n",(0,t.jsx)(n.li,{children:"348 bits (3 limbs)"}),"\n",(0,t.jsx)(n.li,{children:"464 bits (4 limbs)"}),"\n",(0,t.jsx)(n.li,{children:"580 bits (5 limbs)"}),"\n",(0,t.jsx)(n.li,{children:"1044 bits (9 limbs)"}),"\n",(0,t.jsx)(n.li,{children:"2088 bits (18 limbs)"}),"\n",(0,t.jsx)(n.li,{children:"4176 bits (36 limbs)"}),"\n"]}),"\n",(0,t.jsx)(n.p,{children:"Each arithmetic operation ensures the result is a valid element of the prime field."}),"\n",(0,t.jsx)(n.h2,{id:"parameters",children:"Parameters"}),"\n",(0,t.jsx)(n.h3,{id:"modulus",children:"modulus"}),"\n",(0,t.jsx)(n.p,{children:(0,t.jsx)(n.code,{children:"bigint"})}),"\n",(0,t.jsx)(n.p,{children:"The modulus for the big integer arithmetic (must be prime)"}),"\n",(0,t.jsx)(n.h3,{id:"config",children:"config?"}),"\n",(0,t.jsx)(n.p,{children:(0,t.jsx)(n.code,{children:"BigIntParameter"})}),"\n",(0,t.jsx)(n.p,{children:"Optional configuration specifying a custom limb size and number"}),"\n",(0,t.jsx)(n.h2,{id:"returns",children:"Returns"}),"\n",(0,t.jsxs)(n.p,{children:[(0,t.jsx)(n.em,{children:"typeof"})," ",(0,t.jsx)(n.code,{children:"ProvableBigInt_"})]}),"\n",(0,t.jsx)(n.p,{children:"A class representing ProvableBigInts with the specified modulus"}),"\n",(0,t.jsx)(n.h2,{id:"example",children:"Example"}),"\n",(0,t.jsx)(n.pre,{children:(0,t.jsx)(n.code,{className:"language-ts",children:"// Create a Provable BigInt class with modulus 2^521 - 1\nconst BigInt521 = createProvableBigInt(2n ** 521n - 1n);\n\n// Create instances\nconst a = BigInt521.fromBigInt(123n);\nconst b = BigInt521.fromBigInt(456n);\nconst c = BigInt521.fromBigInt(1024n);\n\n// Perform operations\nconst sum = a.add(b);\nconst double = a.double();\nconst diff = a.sub(b);\nconst product = a.mul(b);\nconst square = a.square();\nconst quotient = a.div(b);\nconst inverse = a.inverse();\nconst negation = a.negate();\nconst power = a.pow(b);\nconst sqrt = c.sqrt();\n"})}),"\n",(0,t.jsx)(n.p,{children:"The class automatically handles modular reduction after\narithmetic operations to maintain valid representations. All operations are\ndesigned to be provable and optimised for less constraints."}),"\n",(0,t.jsx)(n.h2,{id:"throws",children:"Throws"}),"\n",(0,t.jsx)(n.p,{children:"If the modulus is zero, negative, or exceeds the maximum supported size"})]})}function u(e={}){const{wrapper:n}={...(0,r.R)(),...e.components};return n?(0,t.jsx)(n,{...e,children:(0,t.jsx)(d,{...e})}):d(e)}}}]);