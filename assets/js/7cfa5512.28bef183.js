"use strict";(self.webpackChunkdocumentation_site=self.webpackChunkdocumentation_site||[]).push([[63789],{12797:(e,t,n)=>{n.r(t),n.d(t,{assets:()=>d,contentTitle:()=>l,default:()=>p,frontMatter:()=>c,metadata:()=>s,toc:()=>m});const s=JSON.parse('{"id":"writing-constraint-systems/analyzing-constraint-systems","title":"Analyzing Constraints","description":"Optimizing o1js code is often not a matter of copying over optimized functions traditional programming languages, but instead","source":"@site/docs/writing-constraint-systems/analyzing-constraint-systems.mdx","sourceDirName":"writing-constraint-systems","slug":"/writing-constraint-systems/analyzing-constraint-systems","permalink":"/o1js/writing-constraint-systems/analyzing-constraint-systems","draft":false,"unlisted":false,"editUrl":"https://github.com/docs/writing-constraint-systems/analyzing-constraint-systems.mdx","tags":[],"version":"current","frontMatter":{"title":"Analyzing Constraints"},"sidebar":"docs","previous":{"title":"Conditional Logic","permalink":"/o1js/writing-constraint-systems/conditional-logic"},"next":{"title":"Full Proof Flow with ZkProgram","permalink":"/o1js/writing-constraint-systems/zk-program"}}');var a=n(74848),o=n(28453),r=n(43474),i=n(58069);const c={title:"Analyzing Constraints"},l=void 0,d={},m=[{value:"Example provable function",id:"example-provable-function",level:4},{value:"Using Provable.constraintSystem",id:"using-provableconstraintsystem",level:2},{value:"Using ZkProgram",id:"using-zkprogram",level:2},{value:"Using SmartContract",id:"using-smartcontract",level:2}];function h(e){const t={a:"a",admonition:"admonition",code:"code",h2:"h2",h4:"h4",p:"p",pre:"pre",...(0,o.R)(),...e.components};return(0,a.jsxs)(a.Fragment,{children:[(0,a.jsx)(t.p,{children:"Optimizing o1js code is often not a matter of copying over optimized functions traditional programming languages, but instead\na matter of minimizing the number of constraints required to model the code.  It's important to analyze the functions you write\nto understand the constraint system that they generate.  o1js provides the tools you need to understand how many, and what\ntypes of constraints your program generates."}),"\n",(0,a.jsx)(t.h4,{id:"example-provable-function",children:"Example provable function"}),"\n",(0,a.jsx)(t.p,{children:"For the following examples, let's define a dummy function that we can reuse in different contexts:"}),"\n",(0,a.jsx)(t.pre,{children:(0,a.jsx)(t.code,{className:"language-ts",metastring:"file=../snippets/constraint-system/constraint-system.ts start=start_example_provable_function end=end_example_provable_function",children:"function exampleProvableFunction() {\n  const x = Provable.witness(Field, () => Field(10));\n  const y = Provable.witness(Field, () => Field(20));\n\n  y.assertGreaterThan(x);\n  return Poseidon.hash([x, y]);\n}\n"})}),"\n",(0,a.jsx)(t.h2,{id:"using-provableconstraintsystem",children:"Using Provable.constraintSystem"}),"\n",(0,a.jsxs)(t.p,{children:[(0,a.jsx)(t.code,{children:"Provable.constraintSystem"}),' is a way to create something like a "snippet" of provable code.  o1js can convert the snippet into a\nconstraint system, which can then be analyzed.  This simple wrapper is the lightest-weight way to quickly analyze some provable\ncode.  You can also use it to analyze specific pieces of a larger program, or specific functions.']}),"\n",(0,a.jsx)(t.admonition,{type:"note",children:(0,a.jsx)(t.p,{children:"This will not check correctness of the code.  It will only convert the code into a constraint system, which is essentially a list of steps to execute.\nIt will not execute the steps, or provide any guarantees that the constraint system generated is correct or secure."})}),"\n",(0,a.jsx)(t.pre,{children:(0,a.jsx)(t.code,{className:"language-ts",metastring:"file=../snippets/constraint-system/constraint-system.ts start=start_constraint_system_example end=end_constraint_system_example",children:"const cs = await Provable.constraintSystem(() => {\n  exampleProvableFunction();\n});\n\ncs.summary(); // Count of constraints, grouped by gate type\ncs.rows; // Count of total constraints\ncs.gates; // Array of gates that make up the constraint system (essentially a serialization of the raw system)\n"})}),"\n",(0,a.jsx)(t.p,{children:"The summary looks like this:"}),"\n",(0,a.jsx)(i.A,{language:"json",children:JSON.stringify(r.XX,null,2)}),"\n",(0,a.jsxs)(t.p,{children:["Read more at the language reference: ",(0,a.jsx)(t.a,{href:"/o1js/api-reference/variables/Provable#constraintsystem",children:"Provable.constraintSystem"}),"."]}),"\n",(0,a.jsx)(t.h2,{id:"using-zkprogram",children:"Using ZkProgram"}),"\n",(0,a.jsxs)(t.p,{children:[(0,a.jsx)(t.code,{children:"ZkProgram"})," is a more complete provable implementation of a program.  It has proper inputs and outputs, and methods that can be called to\ncreate a proof.  The ",(0,a.jsx)(t.code,{children:"ZkProgram"})," itself can be analyzed, which is a handy shortcut to simply get the analysis output for each method in\nthe program.  ",(0,a.jsx)(t.code,{children:"ZkProgram"})," has type requirements and more configuration required than ",(0,a.jsx)(t.code,{children:"Provable.constraintSystem"}),", so to check just some\npieces of code, ",(0,a.jsx)(t.code,{children:"Provable.constraintSystem"})," is the better choice, but to analyze your methods in the context of a full program that's subject\nto specific return types, inputs, and outputs, ",(0,a.jsx)(t.code,{children:"ZkProgram"})," is the better choice."]}),"\n",(0,a.jsx)(t.admonition,{type:"info",children:(0,a.jsxs)(t.p,{children:[(0,a.jsx)(t.code,{children:"ZkProgram.analyzeMethods"})," uses ",(0,a.jsx)(t.code,{children:"Provable.constraintSystem"})," under the hood, so ultimately, they expose the same functionality.\nThe main difference is the ergonomics of the API.  ",(0,a.jsx)(t.code,{children:"Provable.constraintSystem"})," is a pure constraint system generation tool, while\n",(0,a.jsx)(t.code,{children:"ZkProgram"})," is a more complete provable implementation, of which constraint system generation is one part."]})}),"\n",(0,a.jsx)(t.pre,{children:(0,a.jsx)(t.code,{className:"language-ts",metastring:"file=../snippets/constraint-system/constraint-system.ts start=start_zk_program_example end=end_zk_program_example",children:'const zkp = ZkProgram({\n  name: "Example",\n  publicOutput: Field,\n  methods: {\n    example: {\n      privateInputs: [],\n      method: async () => {\n        const publicOutput = exampleProvableFunction();\n        return { publicOutput };\n      },\n    },\n  },\n});\n\nconst zkpAnalysis = await zkp.analyzeMethods();\n\nzkpAnalysis.example.summary();\nzkpAnalysis.example.rows;\nzkpAnalysis.example.gates;\n'})}),"\n",(0,a.jsx)(t.p,{children:"Note how the same function results in the same constraint system summary:"}),"\n",(0,a.jsx)(i.A,{language:"json",children:JSON.stringify(r.M4,null,2)}),"\n",(0,a.jsxs)(t.p,{children:["Read more at the language reference: ",(0,a.jsx)(t.a,{href:"/o1js/api-reference/functions/ZkProgram",children:"ZkProgram"}),"."]}),"\n",(0,a.jsx)(t.h2,{id:"using-smartcontract",children:"Using SmartContract"}),"\n",(0,a.jsxs)(t.p,{children:[(0,a.jsx)(t.code,{children:"SmartContract"})," is a specialized class for writing proofs that interact with the Mina blockchain.  For the purposes of analyzing the\nconstraint system, it works like ",(0,a.jsx)(t.code,{children:"ZkProgram"}),".  Keep in mind, that not every method on the ",(0,a.jsx)(t.code,{children:"SmartContract"})," actually has to be\nprovable!  Non-provable methods will not be converted into constraint systems.  As a ",(0,a.jsx)(t.code,{children:"class"}),", ",(0,a.jsx)(t.code,{children:"SmartContracts"})," are just a JavaScript\nobject, so you can add any methods you want, just like any class.  Only methods decorated with ",(0,a.jsx)(t.code,{children:"@method"})," will be marked as provable,\nand included in the resulting constraint system."]}),"\n",(0,a.jsxs)(t.admonition,{type:"info",children:[(0,a.jsxs)(t.p,{children:[(0,a.jsx)(t.code,{children:"SmartContract.analyzeMethods"})," uses ",(0,a.jsx)(t.code,{children:"Provable.constraintSystem"})," under the hood, so ultimately, they expose the same functionality.\nJust like ",(0,a.jsx)(t.code,{children:"ZkProgram"}),", ",(0,a.jsx)(t.code,{children:"SmartContract"})," is a complete provable implementation of a program, but it layers on even more extra\nfunctionality in the form of compatibility with the Mina blockchain."]}),(0,a.jsxs)(t.p,{children:["So ",(0,a.jsx)(t.code,{children:"Provable.constraintSystem"})," is strictly a constraint system generation tool.  It's extremely generic and can't be used to create\na proof.  ",(0,a.jsx)(t.code,{children:"ZkProgram"})," is a complete provable program, including constraint system generation, but also proof generation and\nverification.  ",(0,a.jsx)(t.code,{children:"SmartContract"})," is a specialized wrapper around ",(0,a.jsx)(t.code,{children:"ZkProgram"})," that is designed to work with the Mina blockchain.  All\nof these tools can expose generated constraint system analyses."]})]}),"\n",(0,a.jsx)(t.pre,{children:(0,a.jsx)(t.code,{className:"language-ts",metastring:"file=../snippets/constraint-system/constraint-system.ts start=start_smart_contract_example end=end_smart_contract_example",children:"class ExampleContract extends SmartContract {\n  @state(Field) x = State<Field>();\n\n  @method async example(y: Field, knownHash: Field) {\n    const x = this.x.getAndRequireEquals();\n    y.assertGreaterThan(x);\n    Poseidon.hash([x, y]).assertEquals(knownHash);\n    this.x.set(y);\n  }\n\n  // Helper function, totally out of scope for analyzeMethods\n  get stringX() {\n    return this.x.get().toString();\n  }\n}\n\nconst scAnalysis = await ExampleContract.analyzeMethods();\n\nscAnalysis.example.rows;\nscAnalysis.example.gates;\n"})}),"\n",(0,a.jsxs)(t.p,{children:["Read more at the language reference: ",(0,a.jsx)(t.a,{href:"/o1js/api-reference/classes/SmartContract#analyzemethods",children:"SmartContract"}),"."]})]})}function p(e={}){const{wrapper:t}={...(0,o.R)(),...e.components};return t?(0,a.jsx)(t,{...e,children:(0,a.jsx)(h,{...e})}):h(e)}},43474:e=>{e.exports=JSON.parse('{"XX":{"ForeignFieldAdd":3,"Generic":3,"Poseidon":11,"RangeCheck0":8,"RangeCheck1":4,"Total rows":36,"Zero":7},"M4":{"ForeignFieldAdd":3,"Generic":3,"Poseidon":11,"RangeCheck0":8,"RangeCheck1":4,"Total rows":36,"Zero":7}}')}}]);