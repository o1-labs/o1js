"use strict";(self.webpackChunkdocumentation_site=self.webpackChunkdocumentation_site||[]).push([[1428],{29060:(e,s,n)=>{n.r(s),n.d(s,{assets:()=>h,contentTitle:()=>r,default:()=>l,frontMatter:()=>o,metadata:()=>t,toc:()=>c});const t=JSON.parse('{"id":"basic-types/hashing","title":"Hashing","description":"Poseidon","source":"@site/docs/basic-types/hashing.mdx","sourceDirName":"basic-types","slug":"/basic-types/hashing","permalink":"/o1js/basic-types/hashing","draft":false,"unlisted":false,"editUrl":"https://github.com/docs/basic-types/hashing.mdx","tags":[],"version":"current","frontMatter":{"title":"Hashing"},"sidebar":"docs","previous":{"title":"Structs","permalink":"/o1js/basic-types/structs"},"next":{"title":"Witnesses","permalink":"/o1js/writing-constraint-systems/witnesses"}}');var a=n(74848),i=n(28453);n(58069);const o={title:"Hashing"},r=void 0,h={},c=[{value:"Poseidon",id:"poseidon",level:3},{value:"Other Hash Functions",id:"other-hash-functions",level:3}];function d(e){const s={a:"a",code:"code",h3:"h3",p:"p",pre:"pre",...(0,i.R)(),...e.components};return(0,a.jsxs)(a.Fragment,{children:[(0,a.jsx)(s.h3,{id:"poseidon",children:"Poseidon"}),"\n",(0,a.jsxs)(s.p,{children:[(0,a.jsx)(s.a,{href:"https://o1-labs.github.io/proof-systems/specs/poseidon.html",children:"Poseidon"})," is the most efficient hashing algorithm for o1js, and it should be\nused for general purpose hashing.  It operates over Field arrays, and all provable types can be converted to Field arrays."]}),"\n",(0,a.jsx)(s.pre,{children:(0,a.jsx)(s.code,{className:"language-ts",metastring:"file=../snippets/hashing/hashing.ts start=start_poseidon end=end_poseidon",children:"const h = Poseidon.hash([Field(1), Field(2), Field(3)]);\nconst h2 = Poseidon.hash(PrivateKey.random().toFields());\n"})}),"\n",(0,a.jsx)(s.h3,{id:"other-hash-functions",children:"Other Hash Functions"}),"\n",(0,a.jsx)(s.p,{children:"Other hash functions are supported, but should be reserved for cases where a specific hash function is required.  For example,\nproving verification of an ethereum hash would involve calculating a keccak hash.  In general, these other hash functions operate\nover blocks of bytes of a specific size (like 32 bytes)."}),"\n",(0,a.jsx)(s.pre,{children:(0,a.jsx)(s.code,{className:"language-ts",metastring:"file=../snippets/hashing/hashing.ts start=start_other_hashes end=end_other_hashes",children:"class Bytes32 extends Bytes(32) {}\n\nconst blake = Hash.BLAKE2B.hash(Bytes32.random());\nconst sha256 = Hash.SHA2_256.hash(Bytes32.random());\nconst keccak = Hash.Keccak256.hash(Bytes32.random());\n"})}),"\n",(0,a.jsxs)(s.p,{children:["Read more at the language reference: ",(0,a.jsx)(s.a,{href:"/o1js/api-reference/variables/Poseidon",children:"Poseidon"}),", ",(0,a.jsx)(s.a,{href:"/o1js/api-reference/variables/Hash",children:"Hash"}),"."]})]})}function l(e={}){const{wrapper:s}={...(0,i.R)(),...e.components};return s?(0,a.jsx)(s,{...e,children:(0,a.jsx)(d,{...e})}):d(e)}}}]);