"use strict";(self.webpackChunkdocumentation_site=self.webpackChunkdocumentation_site||[]).push([[42188],{23142:(e,n,t)=>{t.r(n),t.d(n,{assets:()=>o,contentTitle:()=>r,default:()=>f,frontMatter:()=>c,metadata:()=>a,toc:()=>l});const a=JSON.parse('{"id":"api-reference/namespaces/Experimental/functions/OffchainState","title":"OffchainState","description":"Defined in173","source":"@site/docs/api-reference/namespaces/Experimental/functions/OffchainState.mdx","sourceDirName":"api-reference/namespaces/Experimental/functions","slug":"/api-reference/namespaces/Experimental/functions/OffchainState","permalink":"/o1js/api-reference/namespaces/Experimental/functions/OffchainState","draft":false,"unlisted":false,"editUrl":"https://github.com/docs/api-reference/namespaces/Experimental/functions/OffchainState.mdx","tags":[],"version":"current","frontMatter":{},"sidebar":"docs","previous":{"title":"IndexedMerkleMap","permalink":"/o1js/api-reference/namespaces/Experimental/functions/IndexedMerkleMap"},"next":{"title":"Recursive","permalink":"/o1js/api-reference/namespaces/Experimental/functions/Recursive"}}');var i=t(74848),s=t(28453);const c={},r=void 0,o={},l=[{value:"Type Parameters",id:"type-parameters",level:2},{value:"Parameters",id:"parameters",level:2},{value:"config",id:"config",level:3},{value:"options?",id:"options",level:3},{value:"logTotalCapacity",id:"logtotalcapacity",level:4},{value:"maxActionsPerProof",id:"maxactionsperproof",level:4},{value:"maxActionsPerUpdate",id:"maxactionsperupdate",level:4},{value:"Returns",id:"returns",level:2}];function d(e){const n={a:"a",code:"code",em:"em",h2:"h2",h3:"h3",h4:"h4",p:"p",pre:"pre",strong:"strong",...(0,s.R)(),...e.components};return(0,i.jsxs)(i.Fragment,{children:[(0,i.jsx)(n.pre,{children:(0,i.jsx)(n.code,{className:"language-ts",children:"function OffchainState<Config>(config: Config, options?: {\n  logTotalCapacity: number;\n  maxActionsPerProof: number;\n  maxActionsPerUpdate: number;\n}): OffchainState<Config>\n"})}),"\n",(0,i.jsxs)(n.p,{children:["Defined in: ",(0,i.jsx)(n.a,{href:"https://github.com/o1-labs/o1js/blob/df1ff77af12d7cbbed4a6167f02815fad4f0dceb/src/index.ts#L173",children:"index.ts:173"})]}),"\n",(0,i.jsxs)(n.p,{children:["Offchain state for a ",(0,i.jsx)(n.code,{children:"SmartContract"}),"."]}),"\n",(0,i.jsx)(n.pre,{children:(0,i.jsx)(n.code,{className:"language-ts",children:"// declare your offchain state\n\nconst offchainState = OffchainState({\n  accounts: OffchainState.Map(PublicKey, UInt64),\n  totalSupply: OffchainState.Field(UInt64),\n});\n\n// use it in a contract, by adding an onchain state field of type `OffchainStateCommitments`\n\nclass MyContract extends SmartContract {\n \\@state(OffchainStateCommitments) offchainState = State(\n   OffchainStateCommitments.empty()\n  );\n\n  // ...\n}\n\n// set the contract instance\n\nlet contract = new MyContract(address);\noffchainState.setContractInstance(contract);\n"})}),"\n",(0,i.jsxs)(n.p,{children:["See the individual methods on ",(0,i.jsx)(n.code,{children:"offchainState"})," for more information on usage."]}),"\n",(0,i.jsx)(n.h2,{id:"type-parameters",children:"Type Parameters"}),"\n",(0,i.jsxs)(n.p,{children:["\u2022 ",(0,i.jsx)(n.strong,{children:"Config"})," ",(0,i.jsx)(n.em,{children:"extends"})," {}"]}),"\n",(0,i.jsx)(n.h2,{id:"parameters",children:"Parameters"}),"\n",(0,i.jsx)(n.h3,{id:"config",children:"config"}),"\n",(0,i.jsx)(n.p,{children:(0,i.jsx)(n.code,{children:"Config"})}),"\n",(0,i.jsx)(n.h3,{id:"options",children:"options?"}),"\n",(0,i.jsx)(n.h4,{id:"logtotalcapacity",children:"logTotalCapacity"}),"\n",(0,i.jsx)(n.p,{children:(0,i.jsx)(n.code,{children:"number"})}),"\n",(0,i.jsx)(n.p,{children:"The base-2 logarithm of the total capacity of the offchain state."}),"\n",(0,i.jsx)(n.p,{children:"Example: if you want to have 1 million individual state fields and map entries available,\nset this to 20, because 2^20 ~= 1M."}),"\n",(0,i.jsx)(n.p,{children:"The default is 30, which allows for ~1 billion entries."}),"\n",(0,i.jsxs)(n.p,{children:["Passing in lower numbers will reduce the number of constraints required to prove offchain state updates,\nwhich we will make proof creation slightly faster.\nInstead, you could also use a smaller total capacity to increase the ",(0,i.jsx)(n.code,{children:"maxActionsPerProof"}),", so that fewer proofs are required,\nwhich will reduce the proof time even more, but only in the case of many actions."]}),"\n",(0,i.jsx)(n.h4,{id:"maxactionsperproof",children:"maxActionsPerProof"}),"\n",(0,i.jsx)(n.p,{children:(0,i.jsx)(n.code,{children:"number"})}),"\n",(0,i.jsx)(n.h4,{id:"maxactionsperupdate",children:"maxActionsPerUpdate"}),"\n",(0,i.jsx)(n.p,{children:(0,i.jsx)(n.code,{children:"number"})}),"\n",(0,i.jsx)(n.p,{children:"The maximum number of offchain state actions that can be included in a single account update."}),"\n",(0,i.jsxs)(n.p,{children:["In other words, you must not call ",(0,i.jsx)(n.code,{children:".update()"})," or ",(0,i.jsx)(n.code,{children:".overwrite()"})," more than this number of times in any of your smart contract methods."]}),"\n",(0,i.jsx)(n.p,{children:"The default is 4."}),"\n",(0,i.jsxs)(n.p,{children:["Note: When increasing this, consider decreasing ",(0,i.jsx)(n.code,{children:"maxActionsPerProof"})," or ",(0,i.jsx)(n.code,{children:"logTotalCapacity"})," in order to not exceed the circuit size limit."]}),"\n",(0,i.jsx)(n.h2,{id:"returns",children:"Returns"}),"\n",(0,i.jsxs)(n.p,{children:[(0,i.jsx)(n.code,{children:"OffchainState"}),"<",(0,i.jsx)(n.code,{children:"Config"}),">"]})]})}function f(e={}){const{wrapper:n}={...(0,s.R)(),...e.components};return n?(0,i.jsx)(n,{...e,children:(0,i.jsx)(d,{...e})}):d(e)}},28453:(e,n,t)=>{t.d(n,{R:()=>c,x:()=>r});var a=t(96540);const i={},s=a.createContext(i);function c(e){const n=a.useContext(s);return a.useMemo((function(){return"function"==typeof e?e(n):{...n,...e}}),[n,e])}function r(e){let n;return n=e.disableParentContext?"function"==typeof e.components?e.components(i):e.components||i:c(e.components),a.createElement(s.Provider,{value:n},e.children)}}}]);