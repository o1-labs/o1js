"use strict";(self.webpackChunkdocumentation_site=self.webpackChunkdocumentation_site||[]).push([[57420],{28453:(e,n,r)=>{r.d(n,{R:()=>a,x:()=>d});var l=r(96540);const s={},i=l.createContext(s);function a(e){const n=l.useContext(i);return l.useMemo((function(){return"function"==typeof e?e(n):{...n,...e}}),[n,e])}function d(e){let n;return n=e.disableParentContext?"function"==typeof e.components?e.components(s):e.components||s:a(e.components),l.createElement(i.Provider,{value:n},e.children)}},95068:(e,n,r)=>{r.r(n),r.d(n,{assets:()=>c,contentTitle:()=>d,default:()=>h,frontMatter:()=>a,metadata:()=>l,toc:()=>t});const l=JSON.parse('{"id":"api-reference/variables/Provable","title":"Provable","description":"Defined in46","source":"@site/docs/api-reference/variables/Provable.mdx","sourceDirName":"api-reference/variables","slug":"/api-reference/variables/Provable","permalink":"/o1js/api-reference/variables/Provable","draft":false,"unlisted":false,"editUrl":"https://github.com/docs/api-reference/variables/Provable.mdx","tags":[],"version":"current","frontMatter":{},"sidebar":"docs","previous":{"title":"Poseidon","permalink":"/o1js/api-reference/variables/Poseidon"},"next":{"title":"ProvableType","permalink":"/o1js/api-reference/variables/ProvableType"}}');var s=r(74848),i=r(28453);const a={},d=void 0,c={},t=[{value:"Type declaration",id:"type-declaration",level:2},{value:"Array()",id:"array",level:3},{value:"Type Parameters",id:"type-parameters",level:4},{value:"Parameters",id:"parameters",level:4},{value:"elementType",id:"elementtype",level:5},{value:"length",id:"length",level:5},{value:"Returns",id:"returns",level:4},{value:"Example",id:"example",level:4},{value:"asProver()",id:"asprover",level:3},{value:"Parameters",id:"parameters-1",level:4},{value:"f",id:"f",level:5},{value:"Returns",id:"returns-1",level:4},{value:"Example",id:"example-1",level:4},{value:"assertEqual()",id:"assertequal",level:3},{value:"Type Parameters",id:"type-parameters-1",level:4},{value:"Parameters",id:"parameters-2",level:4},{value:"type",id:"type",level:5},{value:"x",id:"x",level:5},{value:"y",id:"y",level:5},{value:"Returns",id:"returns-2",level:4},{value:"Type Parameters",id:"type-parameters-2",level:4},{value:"Parameters",id:"parameters-3",level:4},{value:"x",id:"x-1",level:5},{value:"y",id:"y-1",level:5},{value:"Returns",id:"returns-3",level:4},{value:"Example",id:"example-2",level:4},{value:"assertEqualIf()",id:"assertequalif",level:3},{value:"Type Parameters",id:"type-parameters-3",level:4},{value:"Parameters",id:"parameters-4",level:4},{value:"enabled",id:"enabled",level:5},{value:"type",id:"type-1",level:5},{value:"x",id:"x-2",level:5},{value:"y",id:"y-2",level:5},{value:"Returns",id:"returns-4",level:4},{value:"constraintSystem()",id:"constraintsystem",level:3},{value:"Parameters",id:"parameters-5",level:4},{value:"f",id:"f-1",level:5},{value:"Returns",id:"returns-5",level:4},{value:"Example",id:"example-3",level:4},{value:"equal()",id:"equal",level:3},{value:"Type Parameters",id:"type-parameters-4",level:4},{value:"Parameters",id:"parameters-6",level:4},{value:"type",id:"type-2",level:5},{value:"x",id:"x-3",level:5},{value:"y",id:"y-3",level:5},{value:"Returns",id:"returns-6",level:4},{value:"Example",id:"example-4",level:4},{value:"if()",id:"if",level:3},{value:"Type Parameters",id:"type-parameters-5",level:4},{value:"Parameters",id:"parameters-7",level:4},{value:"condition",id:"condition",level:5},{value:"type",id:"type-3",level:5},{value:"x",id:"x-4",level:5},{value:"y",id:"y-4",level:5},{value:"Returns",id:"returns-7",level:4},{value:"Type Parameters",id:"type-parameters-6",level:4},{value:"Parameters",id:"parameters-8",level:4},{value:"condition",id:"condition-1",level:5},{value:"x",id:"x-5",level:5},{value:"y",id:"y-5",level:5},{value:"Returns",id:"returns-8",level:4},{value:"Example",id:"example-5",level:4},{value:"inCheckedComputation()",id:"incheckedcomputation",level:3},{value:"Returns",id:"returns-9",level:4},{value:"Example",id:"example-6",level:4},{value:"inProver()",id:"inprover",level:3},{value:"Returns",id:"returns-10",level:4},{value:"Example",id:"example-7",level:4},{value:"log()",id:"log",level:3},{value:"Parameters",id:"parameters-9",level:4},{value:"args",id:"args",level:5},{value:"Returns",id:"returns-11",level:4},{value:"Example",id:"example-8",level:4},{value:"switch()",id:"switch",level:3},{value:"Type Parameters",id:"type-parameters-7",level:4},{value:"Parameters",id:"parameters-10",level:4},{value:"mask",id:"mask",level:5},{value:"type",id:"type-4",level:5},{value:"values",id:"values",level:5},{value:"__namedParameters",id:"__namedparameters",level:5},{value:"allowNonExclusive",id:"allownonexclusive",level:6},{value:"Returns",id:"returns-12",level:4},{value:"Example",id:"example-9",level:4},{value:"witness()",id:"witness",level:3},{value:"Type Parameters",id:"type-parameters-8",level:4},{value:"Parameters",id:"parameters-11",level:4},{value:"type",id:"type-5",level:5},{value:"compute",id:"compute",level:5},{value:"Returns",id:"returns-13",level:4},{value:"Example",id:"example-10",level:4},{value:"witnessAsync()",id:"witnessasync",level:3},{value:"Type Parameters",id:"type-parameters-9",level:4},{value:"Parameters",id:"parameters-12",level:4},{value:"type",id:"type-6",level:5},{value:"compute",id:"compute-1",level:5},{value:"Returns",id:"returns-14",level:4},{value:"witnessFields()",id:"witnessfields",level:3},{value:"Type Parameters",id:"type-parameters-10",level:4},{value:"Parameters",id:"parameters-13",level:4},{value:"size",id:"size",level:5},{value:"compute",id:"compute-2",level:5},{value:"Returns",id:"returns-15",level:4},{value:"runAndCheck()",id:"runandcheck",level:3},{value:"Parameters",id:"parameters-14",level:4},{value:"f",id:"f-2",level:5},{value:"Returns",id:"returns-16",level:4},{value:"Example",id:"example-11",level:4},{value:"runUnchecked()",id:"rununchecked",level:3},{value:"Parameters",id:"parameters-15",level:4},{value:"f",id:"f-3",level:5},{value:"Returns",id:"returns-17",level:4},{value:"Example",id:"example-12",level:4},{value:"toCanonical()",id:"tocanonical",level:3},{value:"Type Parameters",id:"type-parameters-11",level:4},{value:"Parameters",id:"parameters-16",level:4},{value:"type",id:"type-7",level:5},{value:"value",id:"value",level:5},{value:"Returns",id:"returns-18",level:4},{value:"toConstant()",id:"toconstant",level:3},{value:"Type Parameters",id:"type-parameters-12",level:4},{value:"Parameters",id:"parameters-17",level:4},{value:"type",id:"type-8",level:5},{value:"value",id:"value-1",level:5},{value:"Returns",id:"returns-19",level:4}];function o(e){const n={a:"a",code:"code",em:"em",h2:"h2",h3:"h3",h4:"h4",h5:"h5",h6:"h6",p:"p",pre:"pre",strong:"strong",...(0,i.R)(),...e.components};return(0,s.jsxs)(s.Fragment,{children:[(0,s.jsx)(n.pre,{children:(0,s.jsx)(n.code,{className:"language-ts",children:"Provable: {\n  Array: <A>(elementType: A, length: number) => InferredProvable<ToProvable<A>[]>;\n  asProver: (f: () => void) => void;\n  assertEqual: <T>(type: FlexibleProvableType<T>, x: T, y: T) => void<T>(x: T, y: T) => void;\n  assertEqualIf: <A, T>(enabled: Bool, type: A, x: T, y: T) => void;\n  constraintSystem: (f: () => Promise<void> | () => void) => Promise<ConstraintSystemSummary>;\n  equal: <T>(type: FlexibleProvableType<T>, x: T, y: T) => Bool;\n  if: <T>(condition: Bool, type: FlexibleProvableType<T>, x: T, y: T) => T<T>(condition: Bool, x: T, y: T) => T;\n  inCheckedComputation: () => boolean;\n  inProver: () => boolean;\n  log: (...args: any) => void;\n  switch: <T, A>(mask: Bool[], type: A, values: T[], __namedParameters: {\n     allowNonExclusive: boolean;\n    }) => T;\n  witness: <A, T>(type: A, compute: () => T) => InferProvable<ToProvable<A>>;\n  witnessAsync: <A, T>(type: A, compute: () => Promise<T>) => Promise<T>;\n  witnessFields: <N, C>(size: N, compute: C) => TupleN<Field, N>;\n  runAndCheck: Promise<void>;\n  runUnchecked: Promise<void>;\n  toCanonical: T;\n  toConstant: T;\n};\n"})}),"\n",(0,s.jsxs)(n.p,{children:["Defined in: ",(0,s.jsx)(n.a,{href:"https://github.com/o1-labs/o1js/blob/df1ff77af12d7cbbed4a6167f02815fad4f0dceb/src/lib/provable/provable.ts#L46",children:"lib/provable/provable.ts:46"})]}),"\n",(0,s.jsx)(n.h2,{id:"type-declaration",children:"Type declaration"}),"\n",(0,s.jsx)(n.h3,{id:"array",children:"Array()"}),"\n",(0,s.jsx)(n.pre,{children:(0,s.jsx)(n.code,{className:"language-ts",children:"Array: <A>(elementType: A, length: number) => InferredProvable<ToProvable<A>[]> = provableArray;\n"})}),"\n",(0,s.jsxs)(n.p,{children:["Creates a ",(0,s.jsx)(n.a,{href:"/o1js/api-reference/variables/Provable",children:"Provable"})," for a generic array."]}),"\n",(0,s.jsx)(n.h4,{id:"type-parameters",children:"Type Parameters"}),"\n",(0,s.jsxs)(n.p,{children:["\u2022 ",(0,s.jsx)(n.strong,{children:"A"})," ",(0,s.jsx)(n.em,{children:"extends"})," ",(0,s.jsx)(n.code,{children:"FlexibleProvableType"}),"<",(0,s.jsx)(n.code,{children:"any"}),">"]}),"\n",(0,s.jsx)(n.h4,{id:"parameters",children:"Parameters"}),"\n",(0,s.jsx)(n.h5,{id:"elementtype",children:"elementType"}),"\n",(0,s.jsx)(n.p,{children:(0,s.jsx)(n.code,{children:"A"})}),"\n",(0,s.jsx)(n.h5,{id:"length",children:"length"}),"\n",(0,s.jsx)(n.p,{children:(0,s.jsx)(n.code,{children:"number"})}),"\n",(0,s.jsx)(n.h4,{id:"returns",children:"Returns"}),"\n",(0,s.jsxs)(n.p,{children:[(0,s.jsx)(n.code,{children:"InferredProvable"}),"<",(0,s.jsx)(n.a,{href:"/o1js/api-reference/type-aliases/ToProvable",children:(0,s.jsx)(n.code,{children:"ToProvable"})}),"<",(0,s.jsx)(n.code,{children:"A"}),">[]>"]}),"\n",(0,s.jsx)(n.h4,{id:"example",children:"Example"}),"\n",(0,s.jsx)(n.pre,{children:(0,s.jsx)(n.code,{className:"language-ts",children:"const ProvableArray = Provable.Array(Field, 5);\n"})}),"\n",(0,s.jsx)(n.h3,{id:"asprover",children:"asProver()"}),"\n",(0,s.jsx)(n.pre,{children:(0,s.jsx)(n.code,{className:"language-ts",children:"asProver: (f: () => void) => void;\n"})}),"\n",(0,s.jsx)(n.p,{children:"Runs code as a prover."}),"\n",(0,s.jsx)(n.h4,{id:"parameters-1",children:"Parameters"}),"\n",(0,s.jsx)(n.h5,{id:"f",children:"f"}),"\n",(0,s.jsxs)(n.p,{children:["() => ",(0,s.jsx)(n.code,{children:"void"})]}),"\n",(0,s.jsx)(n.h4,{id:"returns-1",children:"Returns"}),"\n",(0,s.jsx)(n.p,{children:(0,s.jsx)(n.code,{children:"void"})}),"\n",(0,s.jsx)(n.h4,{id:"example-1",children:"Example"}),"\n",(0,s.jsx)(n.pre,{children:(0,s.jsx)(n.code,{className:"language-ts",children:"Provable.asProver(() => {\n  // Your prover code here\n});\n"})}),"\n",(0,s.jsx)(n.h3,{id:"assertequal",children:"assertEqual()"}),"\n",(0,s.jsx)(n.pre,{children:(0,s.jsx)(n.code,{className:"language-ts",children:"assertEqual: <T>(type: FlexibleProvableType<T>, x: T, y: T) => void<T>(x: T, y: T) => void;\n"})}),"\n",(0,s.jsx)(n.p,{children:"Asserts that two values are equal."}),"\n",(0,s.jsx)(n.h4,{id:"type-parameters-1",children:"Type Parameters"}),"\n",(0,s.jsxs)(n.p,{children:["\u2022 ",(0,s.jsx)(n.strong,{children:"T"})]}),"\n",(0,s.jsx)(n.h4,{id:"parameters-2",children:"Parameters"}),"\n",(0,s.jsx)(n.h5,{id:"type",children:"type"}),"\n",(0,s.jsxs)(n.p,{children:[(0,s.jsx)(n.code,{children:"FlexibleProvableType"}),"<",(0,s.jsx)(n.code,{children:"T"}),">"]}),"\n",(0,s.jsx)(n.h5,{id:"x",children:"x"}),"\n",(0,s.jsx)(n.p,{children:(0,s.jsx)(n.code,{children:"T"})}),"\n",(0,s.jsx)(n.h5,{id:"y",children:"y"}),"\n",(0,s.jsx)(n.p,{children:(0,s.jsx)(n.code,{children:"T"})}),"\n",(0,s.jsx)(n.h4,{id:"returns-2",children:"Returns"}),"\n",(0,s.jsx)(n.p,{children:(0,s.jsx)(n.code,{children:"void"})}),"\n",(0,s.jsx)(n.h4,{id:"type-parameters-2",children:"Type Parameters"}),"\n",(0,s.jsxs)(n.p,{children:["\u2022 ",(0,s.jsx)(n.strong,{children:"T"})," ",(0,s.jsx)(n.em,{children:"extends"})," ",(0,s.jsx)(n.code,{children:"ToFieldable"})]}),"\n",(0,s.jsx)(n.h4,{id:"parameters-3",children:"Parameters"}),"\n",(0,s.jsx)(n.h5,{id:"x-1",children:"x"}),"\n",(0,s.jsx)(n.p,{children:(0,s.jsx)(n.code,{children:"T"})}),"\n",(0,s.jsx)(n.h5,{id:"y-1",children:"y"}),"\n",(0,s.jsx)(n.p,{children:(0,s.jsx)(n.code,{children:"T"})}),"\n",(0,s.jsx)(n.h4,{id:"returns-3",children:"Returns"}),"\n",(0,s.jsx)(n.p,{children:(0,s.jsx)(n.code,{children:"void"})}),"\n",(0,s.jsx)(n.h4,{id:"example-2",children:"Example"}),"\n",(0,s.jsx)(n.pre,{children:(0,s.jsx)(n.code,{className:"language-ts",children:"class MyStruct extends Struct({ a: Field, b: Bool }) {};\nconst a: MyStruct = { a: Field(0), b: Bool(false) };\nconst b: MyStruct = { a: Field(1), b: Bool(true) };\nProvable.assertEqual(MyStruct, a, b);\n"})}),"\n",(0,s.jsx)(n.h3,{id:"assertequalif",children:"assertEqualIf()"}),"\n",(0,s.jsx)(n.pre,{children:(0,s.jsx)(n.code,{className:"language-ts",children:"assertEqualIf: <A, T>(enabled: Bool, type: A, x: T, y: T) => void;\n"})}),"\n",(0,s.jsx)(n.p,{children:"Asserts that two values are equal, if an enabling condition is true."}),"\n",(0,s.jsx)(n.p,{children:"If the condition is false, the assertion is skipped."}),"\n",(0,s.jsx)(n.h4,{id:"type-parameters-3",children:"Type Parameters"}),"\n",(0,s.jsxs)(n.p,{children:["\u2022 ",(0,s.jsx)(n.strong,{children:"A"})," ",(0,s.jsx)(n.em,{children:"extends"})," ",(0,s.jsx)(n.a,{href:"/o1js/api-reference/type-aliases/ProvableType",children:(0,s.jsx)(n.code,{children:"ProvableType"})}),"<",(0,s.jsx)(n.code,{children:"any"}),">"]}),"\n",(0,s.jsxs)(n.p,{children:["\u2022 ",(0,s.jsx)(n.strong,{children:"T"})," ",(0,s.jsx)(n.em,{children:"extends"})," ",(0,s.jsx)(n.code,{children:"any"})," = ",(0,s.jsx)(n.code,{children:"InferProvableType"}),"<",(0,s.jsx)(n.code,{children:"A"}),">"]}),"\n",(0,s.jsx)(n.h4,{id:"parameters-4",children:"Parameters"}),"\n",(0,s.jsx)(n.h5,{id:"enabled",children:"enabled"}),"\n",(0,s.jsx)(n.p,{children:(0,s.jsx)(n.a,{href:"/o1js/api-reference/classes/Bool",children:(0,s.jsx)(n.code,{children:"Bool"})})}),"\n",(0,s.jsx)(n.h5,{id:"type-1",children:"type"}),"\n",(0,s.jsx)(n.p,{children:(0,s.jsx)(n.code,{children:"A"})}),"\n",(0,s.jsx)(n.h5,{id:"x-2",children:"x"}),"\n",(0,s.jsx)(n.p,{children:(0,s.jsx)(n.code,{children:"T"})}),"\n",(0,s.jsx)(n.h5,{id:"y-2",children:"y"}),"\n",(0,s.jsx)(n.p,{children:(0,s.jsx)(n.code,{children:"T"})}),"\n",(0,s.jsx)(n.h4,{id:"returns-4",children:"Returns"}),"\n",(0,s.jsx)(n.p,{children:(0,s.jsx)(n.code,{children:"void"})}),"\n",(0,s.jsx)(n.h3,{id:"constraintsystem",children:"constraintSystem()"}),"\n",(0,s.jsx)(n.pre,{children:(0,s.jsx)(n.code,{className:"language-ts",children:"constraintSystem: (f: () => Promise<void> | () => void) => Promise<ConstraintSystemSummary>;\n"})}),"\n",(0,s.jsx)(n.p,{children:"Returns information about the constraints created by the callback function."}),"\n",(0,s.jsx)(n.h4,{id:"parameters-5",children:"Parameters"}),"\n",(0,s.jsx)(n.h5,{id:"f-1",children:"f"}),"\n",(0,s.jsxs)(n.p,{children:["() => ",(0,s.jsx)(n.code,{children:"Promise"}),"<",(0,s.jsx)(n.code,{children:"void"}),"> | () => ",(0,s.jsx)(n.code,{children:"void"})]}),"\n",(0,s.jsx)(n.h4,{id:"returns-5",children:"Returns"}),"\n",(0,s.jsxs)(n.p,{children:[(0,s.jsx)(n.code,{children:"Promise"}),"<",(0,s.jsx)(n.code,{children:"ConstraintSystemSummary"}),">"]}),"\n",(0,s.jsx)(n.h4,{id:"example-3",children:"Example"}),"\n",(0,s.jsx)(n.pre,{children:(0,s.jsx)(n.code,{className:"language-ts",children:"const result = await Provable.constraintSystem(circuit);\nconsole.log(result);\n"})}),"\n",(0,s.jsx)(n.h3,{id:"equal",children:"equal()"}),"\n",(0,s.jsx)(n.pre,{children:(0,s.jsx)(n.code,{className:"language-ts",children:"equal: <T>(type: FlexibleProvableType<T>, x: T, y: T) => Bool;\n"})}),"\n",(0,s.jsx)(n.p,{children:"Checks if two elements are equal."}),"\n",(0,s.jsx)(n.h4,{id:"type-parameters-4",children:"Type Parameters"}),"\n",(0,s.jsxs)(n.p,{children:["\u2022 ",(0,s.jsx)(n.strong,{children:"T"})]}),"\n",(0,s.jsx)(n.h4,{id:"parameters-6",children:"Parameters"}),"\n",(0,s.jsx)(n.h5,{id:"type-2",children:"type"}),"\n",(0,s.jsxs)(n.p,{children:[(0,s.jsx)(n.code,{children:"FlexibleProvableType"}),"<",(0,s.jsx)(n.code,{children:"T"}),">"]}),"\n",(0,s.jsx)(n.h5,{id:"x-3",children:"x"}),"\n",(0,s.jsx)(n.p,{children:(0,s.jsx)(n.code,{children:"T"})}),"\n",(0,s.jsx)(n.h5,{id:"y-3",children:"y"}),"\n",(0,s.jsx)(n.p,{children:(0,s.jsx)(n.code,{children:"T"})}),"\n",(0,s.jsx)(n.h4,{id:"returns-6",children:"Returns"}),"\n",(0,s.jsx)(n.p,{children:(0,s.jsx)(n.a,{href:"/o1js/api-reference/classes/Bool",children:(0,s.jsx)(n.code,{children:"Bool"})})}),"\n",(0,s.jsx)(n.h4,{id:"example-4",children:"Example"}),"\n",(0,s.jsx)(n.pre,{children:(0,s.jsx)(n.code,{className:"language-ts",children:"class MyStruct extends Struct({ a: Field, b: Bool }) {};\nconst a: MyStruct = { a: Field(0), b: Bool(false) };\nconst b: MyStruct = { a: Field(1), b: Bool(true) };\nconst isEqual = Provable.equal(MyStruct, a, b);\n"})}),"\n",(0,s.jsx)(n.h3,{id:"if",children:"if()"}),"\n",(0,s.jsx)(n.pre,{children:(0,s.jsx)(n.code,{className:"language-ts",children:"if: <T>(condition: Bool, type: FlexibleProvableType<T>, x: T, y: T) => T<T>(condition: Bool, x: T, y: T) => T = if_;\n"})}),"\n",(0,s.jsx)(n.p,{children:"Proof-compatible if-statement.\nThis behaves like a ternary conditional statement in JS."}),"\n",(0,s.jsxs)(n.p,{children:[(0,s.jsx)(n.strong,{children:"Warning"}),": Since ",(0,s.jsx)(n.code,{children:"Provable.if()"})," is a normal JS function call, both the if and the else branch\nare evaluated before calling it. Therefore, you can't use this function\nto guard against execution of one of the branches. It only allows you to pick one of two values."]}),"\n",(0,s.jsx)(n.h4,{id:"type-parameters-5",children:"Type Parameters"}),"\n",(0,s.jsxs)(n.p,{children:["\u2022 ",(0,s.jsx)(n.strong,{children:"T"})]}),"\n",(0,s.jsx)(n.h4,{id:"parameters-7",children:"Parameters"}),"\n",(0,s.jsx)(n.h5,{id:"condition",children:"condition"}),"\n",(0,s.jsx)(n.p,{children:(0,s.jsx)(n.a,{href:"/o1js/api-reference/classes/Bool",children:(0,s.jsx)(n.code,{children:"Bool"})})}),"\n",(0,s.jsx)(n.h5,{id:"type-3",children:"type"}),"\n",(0,s.jsxs)(n.p,{children:[(0,s.jsx)(n.code,{children:"FlexibleProvableType"}),"<",(0,s.jsx)(n.code,{children:"T"}),">"]}),"\n",(0,s.jsx)(n.h5,{id:"x-4",children:"x"}),"\n",(0,s.jsx)(n.p,{children:(0,s.jsx)(n.code,{children:"T"})}),"\n",(0,s.jsx)(n.h5,{id:"y-4",children:"y"}),"\n",(0,s.jsx)(n.p,{children:(0,s.jsx)(n.code,{children:"T"})}),"\n",(0,s.jsx)(n.h4,{id:"returns-7",children:"Returns"}),"\n",(0,s.jsx)(n.p,{children:(0,s.jsx)(n.code,{children:"T"})}),"\n",(0,s.jsx)(n.h4,{id:"type-parameters-6",children:"Type Parameters"}),"\n",(0,s.jsxs)(n.p,{children:["\u2022 ",(0,s.jsx)(n.strong,{children:"T"})," ",(0,s.jsx)(n.em,{children:"extends"})," ",(0,s.jsx)(n.code,{children:"ToFieldable"})]}),"\n",(0,s.jsx)(n.h4,{id:"parameters-8",children:"Parameters"}),"\n",(0,s.jsx)(n.h5,{id:"condition-1",children:"condition"}),"\n",(0,s.jsx)(n.p,{children:(0,s.jsx)(n.a,{href:"/o1js/api-reference/classes/Bool",children:(0,s.jsx)(n.code,{children:"Bool"})})}),"\n",(0,s.jsx)(n.h5,{id:"x-5",children:"x"}),"\n",(0,s.jsx)(n.p,{children:(0,s.jsx)(n.code,{children:"T"})}),"\n",(0,s.jsx)(n.h5,{id:"y-5",children:"y"}),"\n",(0,s.jsx)(n.p,{children:(0,s.jsx)(n.code,{children:"T"})}),"\n",(0,s.jsx)(n.h4,{id:"returns-8",children:"Returns"}),"\n",(0,s.jsx)(n.p,{children:(0,s.jsx)(n.code,{children:"T"})}),"\n",(0,s.jsx)(n.h4,{id:"example-5",children:"Example"}),"\n",(0,s.jsx)(n.pre,{children:(0,s.jsx)(n.code,{className:"language-ts",children:"const condition = Bool(true);\nconst result = Provable.if(condition, Field(1), Field(2)); // returns Field(1)\n"})}),"\n",(0,s.jsx)(n.h3,{id:"incheckedcomputation",children:"inCheckedComputation()"}),"\n",(0,s.jsx)(n.pre,{children:(0,s.jsx)(n.code,{className:"language-ts",children:"inCheckedComputation: () => boolean;\n"})}),"\n",(0,s.jsx)(n.p,{children:"Checks if the code is run in checked computation mode."}),"\n",(0,s.jsx)(n.h4,{id:"returns-9",children:"Returns"}),"\n",(0,s.jsx)(n.p,{children:(0,s.jsx)(n.code,{children:"boolean"})}),"\n",(0,s.jsx)(n.h4,{id:"example-6",children:"Example"}),"\n",(0,s.jsx)(n.pre,{children:(0,s.jsx)(n.code,{className:"language-ts",children:"if (Provable.inCheckedComputation()) {\n  // Checked computation-specific code\n}\n"})}),"\n",(0,s.jsx)(n.h3,{id:"inprover",children:"inProver()"}),"\n",(0,s.jsx)(n.pre,{children:(0,s.jsx)(n.code,{className:"language-ts",children:"inProver: () => boolean;\n"})}),"\n",(0,s.jsx)(n.p,{children:"Checks if the code is run in prover mode."}),"\n",(0,s.jsx)(n.h4,{id:"returns-10",children:"Returns"}),"\n",(0,s.jsx)(n.p,{children:(0,s.jsx)(n.code,{children:"boolean"})}),"\n",(0,s.jsx)(n.h4,{id:"example-7",children:"Example"}),"\n",(0,s.jsx)(n.pre,{children:(0,s.jsx)(n.code,{className:"language-ts",children:"if (Provable.inProver()) {\n  // Prover-specific code\n}\n"})}),"\n",(0,s.jsx)(n.h3,{id:"log",children:"log()"}),"\n",(0,s.jsx)(n.pre,{children:(0,s.jsx)(n.code,{className:"language-ts",children:"log: (...args: any) => void;\n"})}),"\n",(0,s.jsxs)(n.p,{children:["Interface to log elements within a circuit. Similar to ",(0,s.jsx)(n.code,{children:"console.log()"}),"."]}),"\n",(0,s.jsx)(n.h4,{id:"parameters-9",children:"Parameters"}),"\n",(0,s.jsx)(n.h5,{id:"args",children:"args"}),"\n",(0,s.jsxs)(n.p,{children:["...",(0,s.jsx)(n.code,{children:"any"})]}),"\n",(0,s.jsx)(n.h4,{id:"returns-11",children:"Returns"}),"\n",(0,s.jsx)(n.p,{children:(0,s.jsx)(n.code,{children:"void"})}),"\n",(0,s.jsx)(n.h4,{id:"example-8",children:"Example"}),"\n",(0,s.jsx)(n.pre,{children:(0,s.jsx)(n.code,{className:"language-ts",children:"const element = Field(42);\nProvable.log(element);\n"})}),"\n",(0,s.jsx)(n.h3,{id:"switch",children:"switch()"}),"\n",(0,s.jsx)(n.pre,{children:(0,s.jsx)(n.code,{className:"language-ts",children:"switch: <T, A>(mask: Bool[], type: A, values: T[], __namedParameters: {\n  allowNonExclusive: boolean;\n }) => T = switch_;\n"})}),"\n",(0,s.jsxs)(n.p,{children:["Generalization of ",(0,s.jsx)(n.a,{href:"/o1js/api-reference/variables/Provable#if",children:"Provable.if"}),' for choosing between more than two different cases.\nIt takes a "mask", which is an array of ',(0,s.jsx)(n.code,{children:"Bool"}),"s that contains only one ",(0,s.jsx)(n.code,{children:"true"})," element, a type/constructor, and an array of values of that type.\nThe result is that value which corresponds to the true element of the mask."]}),"\n",(0,s.jsx)(n.h4,{id:"type-parameters-7",children:"Type Parameters"}),"\n",(0,s.jsxs)(n.p,{children:["\u2022 ",(0,s.jsx)(n.strong,{children:"T"})]}),"\n",(0,s.jsxs)(n.p,{children:["\u2022 ",(0,s.jsx)(n.strong,{children:"A"})," ",(0,s.jsx)(n.em,{children:"extends"})," ",(0,s.jsx)(n.code,{children:"FlexibleProvableType"}),"<",(0,s.jsx)(n.code,{children:"T"}),">"]}),"\n",(0,s.jsx)(n.h4,{id:"parameters-10",children:"Parameters"}),"\n",(0,s.jsx)(n.h5,{id:"mask",children:"mask"}),"\n",(0,s.jsxs)(n.p,{children:[(0,s.jsx)(n.a,{href:"/o1js/api-reference/classes/Bool",children:(0,s.jsx)(n.code,{children:"Bool"})}),"[]"]}),"\n",(0,s.jsx)(n.h5,{id:"type-4",children:"type"}),"\n",(0,s.jsx)(n.p,{children:(0,s.jsx)(n.code,{children:"A"})}),"\n",(0,s.jsx)(n.h5,{id:"values",children:"values"}),"\n",(0,s.jsxs)(n.p,{children:[(0,s.jsx)(n.code,{children:"T"}),"[]"]}),"\n",(0,s.jsx)(n.h5,{id:"__namedparameters",children:"__namedParameters"}),"\n",(0,s.jsx)(n.h6,{id:"allownonexclusive",children:"allowNonExclusive"}),"\n",(0,s.jsxs)(n.p,{children:[(0,s.jsx)(n.code,{children:"boolean"})," = ",(0,s.jsx)(n.code,{children:"false"})]}),"\n",(0,s.jsx)(n.h4,{id:"returns-12",children:"Returns"}),"\n",(0,s.jsx)(n.p,{children:(0,s.jsx)(n.code,{children:"T"})}),"\n",(0,s.jsx)(n.h4,{id:"example-9",children:"Example"}),"\n",(0,s.jsx)(n.pre,{children:(0,s.jsx)(n.code,{className:"language-ts",children:"let x = Provable.switch([Bool(false), Bool(true)], Field, [Field(1), Field(2)]);\nx.assertEquals(2);\n"})}),"\n",(0,s.jsx)(n.h3,{id:"witness",children:"witness()"}),"\n",(0,s.jsx)(n.pre,{children:(0,s.jsx)(n.code,{className:"language-ts",children:"witness: <A, T>(type: A, compute: () => T) => InferProvable<ToProvable<A>>;\n"})}),"\n",(0,s.jsxs)(n.p,{children:["Create a new witness. A witness, or variable, is a value that is provided as input\nby the prover. This provides a flexible way to introduce values from outside into the circuit.\nHowever, note that nothing about how the value was created is part of the proof - ",(0,s.jsx)(n.code,{children:"Provable.witness"}),"\nbehaves exactly like user input. So, make sure that after receiving the witness you make any assertions\nthat you want to associate with it."]}),"\n",(0,s.jsxs)(n.p,{children:["The only constraints enforced on the witnessed value come from its type. This means\nthe witnessed value may be anything which satisfies the constraints defined in ",(0,s.jsx)(n.code,{children:"Type.check()"}),".\nNote that for composite types like (",(0,s.jsx)(n.a,{href:"/o1js/api-reference/type-aliases/Struct",children:"Struct"}),"s, the\ndefault ",(0,s.jsx)(n.code,{children:"Type.check()"})," method calls ",(0,s.jsx)(n.code,{children:"check()"})," on each ",(0,s.jsx)(n.a,{href:"/o1js/api-reference/type-aliases/Struct",children:"Struct"})," field."]}),"\n",(0,s.jsxs)(n.p,{children:[(0,s.jsx)(n.strong,{children:"Warning:"})," Be ",(0,s.jsx)(n.em,{children:"extremely wary"})," of any custom ",(0,s.jsx)(n.code,{children:"check()"})," methods, which may have forgotten\nto call ",(0,s.jsx)(n.code,{children:"check()"})," on sub-components of the ",(0,s.jsx)(n.a,{href:"/o1js/api-reference/type-aliases/Struct",children:"Struct"}),"."]}),"\n",(0,s.jsx)(n.h4,{id:"type-parameters-8",children:"Type Parameters"}),"\n",(0,s.jsxs)(n.p,{children:["\u2022 ",(0,s.jsx)(n.strong,{children:"A"})," ",(0,s.jsx)(n.em,{children:"extends"})," ",(0,s.jsx)(n.a,{href:"/o1js/api-reference/type-aliases/ProvableType",children:(0,s.jsx)(n.code,{children:"ProvableType"})}),"<",(0,s.jsx)(n.code,{children:"any"}),", ",(0,s.jsx)(n.code,{children:"any"}),">"]}),"\n",(0,s.jsxs)(n.p,{children:["\u2022 ",(0,s.jsx)(n.strong,{children:"T"})," ",(0,s.jsx)(n.em,{children:"extends"})," ",(0,s.jsx)(n.code,{children:"any"})," = ",(0,s.jsx)(n.code,{children:"From"}),"<",(0,s.jsx)(n.a,{href:"/o1js/api-reference/type-aliases/ToProvable",children:(0,s.jsx)(n.code,{children:"ToProvable"})}),"<",(0,s.jsx)(n.code,{children:"A"}),">>"]}),"\n",(0,s.jsx)(n.h4,{id:"parameters-11",children:"Parameters"}),"\n",(0,s.jsx)(n.h5,{id:"type-5",children:"type"}),"\n",(0,s.jsx)(n.p,{children:(0,s.jsx)(n.code,{children:"A"})}),"\n",(0,s.jsx)(n.h5,{id:"compute",children:"compute"}),"\n",(0,s.jsxs)(n.p,{children:["() => ",(0,s.jsx)(n.code,{children:"T"})]}),"\n",(0,s.jsx)(n.h4,{id:"returns-13",children:"Returns"}),"\n",(0,s.jsxs)(n.p,{children:[(0,s.jsx)(n.a,{href:"/o1js/api-reference/type-aliases/InferProvable",children:(0,s.jsx)(n.code,{children:"InferProvable"})}),"<",(0,s.jsx)(n.a,{href:"/o1js/api-reference/type-aliases/ToProvable",children:(0,s.jsx)(n.code,{children:"ToProvable"})}),"<",(0,s.jsx)(n.code,{children:"A"}),">>"]}),"\n",(0,s.jsx)(n.h4,{id:"example-10",children:"Example"}),"\n",(0,s.jsxs)(n.p,{children:["Example for re-implementing ",(0,s.jsx)(n.code,{children:"Field.inv"})," with the help of ",(0,s.jsx)(n.code,{children:"witness"}),":"]}),"\n",(0,s.jsx)(n.pre,{children:(0,s.jsx)(n.code,{className:"language-ts",children:"let invX = Provable.witness(Field, () => {\n  // compute the inverse of `x` outside the circuit, however you like!\n  return Field.inv(x);\n}\n// prove that `invX` is really the inverse of `x`:\ninvX.mul(x).assertEquals(1);\n"})}),"\n",(0,s.jsxs)(n.p,{children:["Example for decomposing a 64-bit integer into two 32-bit limbs. ",(0,s.jsx)(n.a,{href:"/o1js/api-reference/variables/Provable#witness",children:"Provable.witness"})," will\nprove that the two limbs are actually 32-bits, ensuring the decomposition is unique."]}),"\n",(0,s.jsx)(n.pre,{children:(0,s.jsx)(n.code,{className:"language-ts",children:"function decompose(value: UInt64) {\n  // get two arbitrary 32-bit values from the prover\n  let lowerLimb = Provable.witness(UInt32, () => {\n    return value.and(new UInt64(0xffffffffn)).toUInt32();\n  });\n  let upperLimb = Provable.witness(UInt32, () => {\n    return value\n      .and(new UInt64(0xffffffff00000000n))\n      .div(2 ** 32)\n      .toUInt32();\n  });\n  // prove the 32-bit lower and upper limbs match the 64-bit value\n  value.assertEquals(\n    lowerLimb\n      .toUInt64()\n      .add(upperLimb.toUInt64().mul(UInt64.from(2n ** 32n)))\n  );\n}\n"})}),"\n",(0,s.jsxs)(n.p,{children:["Modified example for decomposing a 64-bit integer into two 32-bit limbs.\nThis time we use a ",(0,s.jsx)(n.a,{href:"/o1js/api-reference/type-aliases/Struct",children:"Struct"})," to get both 32-bit values from the prover at once,\nwhile still proving each limb is actually 32 bits."]}),"\n",(0,s.jsx)(n.pre,{children:(0,s.jsx)(n.code,{className:"language-ts",children:"class Decomposition extends Struct({\n  lower: UInt32,\n  upper: UInt32,\n}) {}\n\nfunction decompose(value: UInt64) {\n  // get two arbitrary 32-bit values from the prover\n  let limbs = Provable.witness(Decomposition, () => {\n    return new Decomposition({\n      lower: value.and(new UInt64(0xffffffffn)).toUInt32(),\n      upper: value\n        .and(new UInt64(0xffffffff00000000n))\n        .div(2 ** 32)\n        .toUInt32(),\n    });\n  });\n  // prove the 32-bit lower and upper limbs match the 64-bit value\n  value.assertEquals(\n    limbs.lower\n      .toUInt64()\n      .add(limbs.upper.toUInt64().mul(UInt64.from(2n ** 32n)))\n  );\n}\n"})}),"\n",(0,s.jsx)(n.h3,{id:"witnessasync",children:"witnessAsync()"}),"\n",(0,s.jsx)(n.pre,{children:(0,s.jsx)(n.code,{className:"language-ts",children:"witnessAsync: <A, T>(type: A, compute: () => Promise<T>) => Promise<T>;\n"})}),"\n",(0,s.jsx)(n.p,{children:"Create a new witness from an async callback."}),"\n",(0,s.jsxs)(n.p,{children:["See ",(0,s.jsx)(n.a,{href:"/o1js/api-reference/variables/Provable#witness",children:"Provable.witness"})," for more information."]}),"\n",(0,s.jsx)(n.h4,{id:"type-parameters-9",children:"Type Parameters"}),"\n",(0,s.jsxs)(n.p,{children:["\u2022 ",(0,s.jsx)(n.strong,{children:"A"})," ",(0,s.jsx)(n.em,{children:"extends"})," ",(0,s.jsx)(n.a,{href:"/o1js/api-reference/type-aliases/ProvableType",children:(0,s.jsx)(n.code,{children:"ProvableType"})}),"<",(0,s.jsx)(n.code,{children:"any"}),", ",(0,s.jsx)(n.code,{children:"any"}),">"]}),"\n",(0,s.jsxs)(n.p,{children:["\u2022 ",(0,s.jsx)(n.strong,{children:"T"})," ",(0,s.jsx)(n.em,{children:"extends"})," ",(0,s.jsx)(n.code,{children:"any"})," = ",(0,s.jsx)(n.code,{children:"From"}),"<",(0,s.jsx)(n.a,{href:"/o1js/api-reference/type-aliases/ToProvable",children:(0,s.jsx)(n.code,{children:"ToProvable"})}),"<",(0,s.jsx)(n.code,{children:"A"}),">>"]}),"\n",(0,s.jsx)(n.h4,{id:"parameters-12",children:"Parameters"}),"\n",(0,s.jsx)(n.h5,{id:"type-6",children:"type"}),"\n",(0,s.jsx)(n.p,{children:(0,s.jsx)(n.code,{children:"A"})}),"\n",(0,s.jsx)(n.h5,{id:"compute-1",children:"compute"}),"\n",(0,s.jsxs)(n.p,{children:["() => ",(0,s.jsx)(n.code,{children:"Promise"}),"<",(0,s.jsx)(n.code,{children:"T"}),">"]}),"\n",(0,s.jsx)(n.h4,{id:"returns-14",children:"Returns"}),"\n",(0,s.jsxs)(n.p,{children:[(0,s.jsx)(n.code,{children:"Promise"}),"<",(0,s.jsx)(n.code,{children:"T"}),">"]}),"\n",(0,s.jsx)(n.h3,{id:"witnessfields",children:"witnessFields()"}),"\n",(0,s.jsx)(n.pre,{children:(0,s.jsx)(n.code,{className:"language-ts",children:"witnessFields: <N, C>(size: N, compute: C) => TupleN<Field, N>;\n"})}),"\n",(0,s.jsxs)(n.p,{children:["Witness a tuple of field elements. This works just like ",(0,s.jsx)(n.a,{href:"/o1js/api-reference/variables/Provable#witness",children:"Provable.witness"}),",\nbut optimized for witnessing plain field elements, which is especially common\nin low-level provable code."]}),"\n",(0,s.jsx)(n.h4,{id:"type-parameters-10",children:"Type Parameters"}),"\n",(0,s.jsxs)(n.p,{children:["\u2022 ",(0,s.jsx)(n.strong,{children:"N"})," ",(0,s.jsx)(n.em,{children:"extends"})," ",(0,s.jsx)(n.code,{children:"number"})]}),"\n",(0,s.jsxs)(n.p,{children:["\u2022 ",(0,s.jsx)(n.strong,{children:"C"})," ",(0,s.jsx)(n.em,{children:"extends"})," () => ",(0,s.jsx)(n.a,{href:"/o1js/api-reference/type-aliases/TupleN",children:(0,s.jsx)(n.code,{children:"TupleN"})}),"<",(0,s.jsx)(n.code,{children:"bigint"})," | ",(0,s.jsx)(n.a,{href:"/o1js/api-reference/classes/Field",children:(0,s.jsx)(n.code,{children:"Field"})}),", ",(0,s.jsx)(n.code,{children:"N"}),">"]}),"\n",(0,s.jsx)(n.h4,{id:"parameters-13",children:"Parameters"}),"\n",(0,s.jsx)(n.h5,{id:"size",children:"size"}),"\n",(0,s.jsx)(n.p,{children:(0,s.jsx)(n.code,{children:"N"})}),"\n",(0,s.jsx)(n.h5,{id:"compute-2",children:"compute"}),"\n",(0,s.jsx)(n.p,{children:(0,s.jsx)(n.code,{children:"C"})}),"\n",(0,s.jsx)(n.h4,{id:"returns-15",children:"Returns"}),"\n",(0,s.jsxs)(n.p,{children:[(0,s.jsx)(n.a,{href:"/o1js/api-reference/type-aliases/TupleN",children:(0,s.jsx)(n.code,{children:"TupleN"})}),"<",(0,s.jsx)(n.a,{href:"/o1js/api-reference/classes/Field",children:(0,s.jsx)(n.code,{children:"Field"})}),", ",(0,s.jsx)(n.code,{children:"N"}),">"]}),"\n",(0,s.jsx)(n.h3,{id:"runandcheck",children:"runAndCheck()"}),"\n",(0,s.jsx)(n.p,{children:"Runs provable code quickly, without creating a proof, but still checking whether constraints are satisfied."}),"\n",(0,s.jsx)(n.h4,{id:"parameters-14",children:"Parameters"}),"\n",(0,s.jsx)(n.h5,{id:"f-2",children:"f"}),"\n",(0,s.jsxs)(n.p,{children:["() => ",(0,s.jsx)(n.code,{children:"Promise"}),"<",(0,s.jsx)(n.code,{children:"void"}),"> | () => ",(0,s.jsx)(n.code,{children:"void"})]}),"\n",(0,s.jsx)(n.h4,{id:"returns-16",children:"Returns"}),"\n",(0,s.jsxs)(n.p,{children:[(0,s.jsx)(n.code,{children:"Promise"}),"<",(0,s.jsx)(n.code,{children:"void"}),">"]}),"\n",(0,s.jsx)(n.h4,{id:"example-11",children:"Example"}),"\n",(0,s.jsx)(n.pre,{children:(0,s.jsx)(n.code,{className:"language-ts",children:"await Provable.runAndCheck(() => {\n  // Your code to check here\n});\n"})}),"\n",(0,s.jsx)(n.h3,{id:"rununchecked",children:"runUnchecked()"}),"\n",(0,s.jsx)(n.p,{children:"Runs provable code quickly, without creating a proof, and not checking whether constraints are satisfied."}),"\n",(0,s.jsx)(n.h4,{id:"parameters-15",children:"Parameters"}),"\n",(0,s.jsx)(n.h5,{id:"f-3",children:"f"}),"\n",(0,s.jsxs)(n.p,{children:["() => ",(0,s.jsx)(n.code,{children:"Promise"}),"<",(0,s.jsx)(n.code,{children:"void"}),"> | () => ",(0,s.jsx)(n.code,{children:"void"})]}),"\n",(0,s.jsx)(n.h4,{id:"returns-17",children:"Returns"}),"\n",(0,s.jsxs)(n.p,{children:[(0,s.jsx)(n.code,{children:"Promise"}),"<",(0,s.jsx)(n.code,{children:"void"}),">"]}),"\n",(0,s.jsx)(n.h4,{id:"example-12",children:"Example"}),"\n",(0,s.jsx)(n.pre,{children:(0,s.jsx)(n.code,{className:"language-ts",children:"await Provable.runUnchecked(() => {\n  // Your code to run here\n});\n"})}),"\n",(0,s.jsx)(n.h3,{id:"tocanonical",children:"toCanonical()"}),"\n",(0,s.jsxs)(n.p,{children:["Return a canonical version of a value, where\ncanonical is defined by the ",(0,s.jsx)(n.code,{children:"type"}),"."]}),"\n",(0,s.jsx)(n.h4,{id:"type-parameters-11",children:"Type Parameters"}),"\n",(0,s.jsxs)(n.p,{children:["\u2022 ",(0,s.jsx)(n.strong,{children:"T"})]}),"\n",(0,s.jsx)(n.h4,{id:"parameters-16",children:"Parameters"}),"\n",(0,s.jsx)(n.h5,{id:"type-7",children:"type"}),"\n",(0,s.jsxs)(n.p,{children:[(0,s.jsx)(n.a,{href:"/o1js/api-reference/type-aliases/Provable",children:(0,s.jsx)(n.code,{children:"Provable"})}),"<",(0,s.jsx)(n.code,{children:"T"}),", ",(0,s.jsx)(n.code,{children:"any"}),">"]}),"\n",(0,s.jsx)(n.h5,{id:"value",children:"value"}),"\n",(0,s.jsx)(n.p,{children:(0,s.jsx)(n.code,{children:"T"})}),"\n",(0,s.jsx)(n.h4,{id:"returns-18",children:"Returns"}),"\n",(0,s.jsx)(n.p,{children:(0,s.jsx)(n.code,{children:"T"})}),"\n",(0,s.jsx)(n.h3,{id:"toconstant",children:"toConstant()"}),"\n",(0,s.jsx)(n.p,{children:"Returns a constant version of a provable type."}),"\n",(0,s.jsx)(n.h4,{id:"type-parameters-12",children:"Type Parameters"}),"\n",(0,s.jsxs)(n.p,{children:["\u2022 ",(0,s.jsx)(n.strong,{children:"T"})]}),"\n",(0,s.jsx)(n.h4,{id:"parameters-17",children:"Parameters"}),"\n",(0,s.jsx)(n.h5,{id:"type-8",children:"type"}),"\n",(0,s.jsxs)(n.p,{children:[(0,s.jsx)(n.a,{href:"/o1js/api-reference/type-aliases/ProvableType",children:(0,s.jsx)(n.code,{children:"ProvableType"})}),"<",(0,s.jsx)(n.code,{children:"T"}),">"]}),"\n",(0,s.jsx)(n.h5,{id:"value-1",children:"value"}),"\n",(0,s.jsx)(n.p,{children:(0,s.jsx)(n.code,{children:"T"})}),"\n",(0,s.jsx)(n.h4,{id:"returns-19",children:"Returns"}),"\n",(0,s.jsx)(n.p,{children:(0,s.jsx)(n.code,{children:"T"})})]})}function h(e={}){const{wrapper:n}={...(0,i.R)(),...e.components};return n?(0,s.jsx)(n,{...e,children:(0,s.jsx)(o,{...e})}):o(e)}}}]);