"use strict";(self.webpackChunkdocumentation_site=self.webpackChunkdocumentation_site||[]).push([[25449],{16857:(e,n,t)=>{t.r(n),t.d(n,{assets:()=>d,contentTitle:()=>i,default:()=>h,frontMatter:()=>c,metadata:()=>s,toc:()=>l});const s=JSON.parse('{"id":"api-reference/functions/Struct","title":"Struct","description":"Defined in125","source":"@site/versioned_docs/version-2.4.0/api-reference/functions/Struct.mdx","sourceDirName":"api-reference/functions","slug":"/api-reference/functions/Struct","permalink":"/o1js/2.4.0/api-reference/functions/Struct","draft":false,"unlisted":false,"editUrl":"https://github.com/versioned_docs/version-2.4.0/api-reference/functions/Struct.mdx","tags":[],"version":"2.4.0","frontMatter":{},"sidebar":"docs","previous":{"title":"State-1","permalink":"/o1js/2.4.0/api-reference/functions/State-1"},"next":{"title":"VarField","permalink":"/o1js/2.4.0/api-reference/functions/VarField"}}');var r=t(74848),o=t(28453);const c={},i=void 0,d={},l=[{value:"Type Parameters",id:"type-parameters",level:2},{value:"Parameters",id:"parameters",level:2},{value:"type",id:"type",level:3},{value:"Returns",id:"returns",level:2},{value:"Example",id:"example",level:2}];function a(e){const n={a:"a",code:"code",em:"em",h2:"h2",h3:"h3",p:"p",pre:"pre",strong:"strong",...(0,o.R)(),...e.components};return(0,r.jsxs)(r.Fragment,{children:[(0,r.jsx)(n.pre,{children:(0,r.jsx)(n.code,{className:"language-ts",children:"function Struct<A, T, V, J, Pure>(type: A): (value: T) => T & {\n  _isStruct: true;\n } & Pure extends true ? ProvablePure<T, V> : Provable<T, V> & {\n  empty: () => T;\n  fromJSON: (x: J) => T;\n  fromValue: (value: From<A>) => T;\n  toInput: (x: T) => {\n     fields: Field[];\n     packed: [Field, number][];\n    };\n  toJSON: (x: T) => J;\n}\n"})}),"\n",(0,r.jsxs)(n.p,{children:["Defined in: ",(0,r.jsx)(n.a,{href:"https://github.com/o1-labs/o1js/blob/df1ff77af12d7cbbed4a6167f02815fad4f0dceb/src/lib/provable/types/struct.ts#L125",children:"lib/provable/types/struct.ts:125"})]}),"\n",(0,r.jsxs)(n.p,{children:[(0,r.jsx)(n.code,{children:"Struct"})," lets you declare composite types for use in o1js circuits."]}),"\n",(0,r.jsx)(n.p,{children:"These composite types can be passed in as arguments to smart contract methods, used for on-chain state variables\nor as event / action types."}),"\n",(0,r.jsx)(n.h2,{id:"type-parameters",children:"Type Parameters"}),"\n",(0,r.jsxs)(n.p,{children:["\u2022 ",(0,r.jsx)(n.strong,{children:"A"})]}),"\n",(0,r.jsxs)(n.p,{children:["\u2022 ",(0,r.jsx)(n.strong,{children:"T"})," ",(0,r.jsx)(n.em,{children:"extends"})," ",(0,r.jsx)(n.code,{children:"unknown"})," = ",(0,r.jsx)(n.a,{href:"/o1js/2.4.0/api-reference/type-aliases/InferProvable",children:(0,r.jsx)(n.code,{children:"InferProvable"})}),"<",(0,r.jsx)(n.code,{children:"A"}),">"]}),"\n",(0,r.jsxs)(n.p,{children:["\u2022 ",(0,r.jsx)(n.strong,{children:"V"})," ",(0,r.jsx)(n.em,{children:"extends"})," ",(0,r.jsx)(n.code,{children:"unknown"})," = ",(0,r.jsx)(n.code,{children:"InferValue"}),"<",(0,r.jsx)(n.code,{children:"A"}),">"]}),"\n",(0,r.jsxs)(n.p,{children:["\u2022 ",(0,r.jsx)(n.strong,{children:"J"})," ",(0,r.jsx)(n.em,{children:"extends"})," ",(0,r.jsx)(n.code,{children:"unknown"})," = ",(0,r.jsx)(n.code,{children:"InferJson"}),"<",(0,r.jsx)(n.code,{children:"A"}),">"]}),"\n",(0,r.jsxs)(n.p,{children:["\u2022 ",(0,r.jsx)(n.strong,{children:"Pure"})," ",(0,r.jsx)(n.em,{children:"extends"})," ",(0,r.jsx)(n.code,{children:"boolean"})," = ",(0,r.jsx)(n.code,{children:"IsPure"}),"<",(0,r.jsx)(n.code,{children:"A"}),">"]}),"\n",(0,r.jsx)(n.h2,{id:"parameters",children:"Parameters"}),"\n",(0,r.jsx)(n.h3,{id:"type",children:"type"}),"\n",(0,r.jsx)(n.p,{children:(0,r.jsx)(n.code,{children:"A"})}),"\n",(0,r.jsxs)(n.p,{children:["Object specifying the layout of the ",(0,r.jsx)(n.code,{children:"Struct"})]}),"\n",(0,r.jsx)(n.h2,{id:"returns",children:"Returns"}),"\n",(0,r.jsxs)(n.p,{children:["(",(0,r.jsx)(n.code,{children:"value"}),": ",(0,r.jsx)(n.code,{children:"T"}),") => ",(0,r.jsx)(n.code,{children:"T"})," & {\n",(0,r.jsx)(n.code,{children:"_isStruct"}),": ",(0,r.jsx)(n.code,{children:"true"}),";\n} & ",(0,r.jsx)(n.code,{children:"Pure"})," ",(0,r.jsx)(n.em,{children:"extends"})," ",(0,r.jsx)(n.code,{children:"true"})," ? ",(0,r.jsx)(n.a,{href:"/o1js/2.4.0/api-reference/type-aliases/ProvablePure",children:(0,r.jsx)(n.code,{children:"ProvablePure"})}),"<",(0,r.jsx)(n.code,{children:"T"}),", ",(0,r.jsx)(n.code,{children:"V"}),"> : ",(0,r.jsx)(n.a,{href:"/o1js/2.4.0/api-reference/type-aliases/Provable",children:(0,r.jsx)(n.code,{children:"Provable"})}),"<",(0,r.jsx)(n.code,{children:"T"}),", ",(0,r.jsx)(n.code,{children:"V"}),"> & {\n",(0,r.jsx)(n.code,{children:"empty"}),": () => ",(0,r.jsx)(n.code,{children:"T"}),";\n",(0,r.jsx)(n.code,{children:"fromJSON"}),": (",(0,r.jsx)(n.code,{children:"x"}),": ",(0,r.jsx)(n.code,{children:"J"}),") => ",(0,r.jsx)(n.code,{children:"T"}),";\n",(0,r.jsx)(n.code,{children:"fromValue"}),": (",(0,r.jsx)(n.code,{children:"value"}),": ",(0,r.jsx)(n.code,{children:"From"}),"<",(0,r.jsx)(n.code,{children:"A"}),">) => ",(0,r.jsx)(n.code,{children:"T"}),";\n",(0,r.jsx)(n.code,{children:"toInput"}),": (",(0,r.jsx)(n.code,{children:"x"}),": ",(0,r.jsx)(n.code,{children:"T"}),") => {\n",(0,r.jsx)(n.code,{children:"fields"}),": ",(0,r.jsx)(n.a,{href:"/o1js/2.4.0/api-reference/type-aliases/Field",children:(0,r.jsx)(n.code,{children:"Field"})}),"[];\n",(0,r.jsx)(n.code,{children:"packed"}),": [",(0,r.jsx)(n.a,{href:"/o1js/2.4.0/api-reference/type-aliases/Field",children:(0,r.jsx)(n.code,{children:"Field"})}),", ",(0,r.jsx)(n.code,{children:"number"}),"][];\n};\n",(0,r.jsx)(n.code,{children:"toJSON"}),": (",(0,r.jsx)(n.code,{children:"x"}),": ",(0,r.jsx)(n.code,{children:"T"}),") => ",(0,r.jsx)(n.code,{children:"J"}),";\n}"]}),"\n",(0,r.jsx)(n.p,{children:"Class which you can extend"}),"\n",(0,r.jsx)(n.h2,{id:"example",children:"Example"}),"\n",(0,r.jsx)(n.p,{children:'Here\'s an example of creating a "Voter" struct, which holds a public key and a collection of votes on 3 different proposals:'}),"\n",(0,r.jsx)(n.pre,{children:(0,r.jsx)(n.code,{className:"language-ts",children:"let Vote = { hasVoted: Bool, inFavor: Bool };\n\nclass Voter extends Struct({\n  publicKey: PublicKey,\n  votes: [Vote, Vote, Vote]\n}) {}\n\n// use Voter as SmartContract input:\nclass VoterContract extends SmartContract {\n  \\@method register(voter: Voter) {\n    // ...\n  }\n}\n"})}),"\n",(0,r.jsxs)(n.p,{children:["In this example, there are no instance methods on the class. This makes ",(0,r.jsx)(n.code,{children:"Voter"})," type-compatible with an anonymous object of the form\n",(0,r.jsx)(n.code,{children:"{ publicKey: PublicKey, votes: Vote[] }"}),".\nThis mean you don't have to create instances by using ",(0,r.jsx)(n.code,{children:"new Voter(...)"}),", you can operate with plain objects:"]}),"\n",(0,r.jsx)(n.pre,{children:(0,r.jsx)(n.code,{className:"language-ts",children:"voterContract.register({ publicKey, votes });\n"})}),"\n",(0,r.jsx)(n.p,{children:"On the other hand, you can also add your own methods:"}),"\n",(0,r.jsx)(n.pre,{children:(0,r.jsx)(n.code,{className:"language-ts",children:"class Voter extends Struct({\n  publicKey: PublicKey,\n  votes: [Vote, Vote, Vote]\n}) {\n  vote(index: number, inFavor: Bool) {\n    let vote = this.votes[i];\n    vote.hasVoted = Bool(true);\n    vote.inFavor = inFavor;\n  }\n}\n"})}),"\n",(0,r.jsxs)(n.p,{children:["In this case, you'll need the constructor to create instances of ",(0,r.jsx)(n.code,{children:"Voter"}),". It always takes as input the plain object:"]}),"\n",(0,r.jsx)(n.pre,{children:(0,r.jsx)(n.code,{className:"language-ts",children:"let emptyVote = { hasVoted: Bool(false), inFavor: Bool(false) };\nlet voter = new Voter({ publicKey, votes: Array(3).fill(emptyVote) });\nvoter.vote(1, Bool(true));\n"})}),"\n",(0,r.jsx)(n.p,{children:"In addition to creating types composed of Field elements, you can also include auxiliary data which does not become part of the proof.\nThis, for example, allows you to re-use the same type outside o1js methods, where you might want to store additional metadata."}),"\n",(0,r.jsxs)(n.p,{children:["To declare non-proof values of type ",(0,r.jsx)(n.code,{children:"string"}),", ",(0,r.jsx)(n.code,{children:"number"}),", etc, you can use the built-in objects ",(0,r.jsx)(n.code,{children:"String"}),", ",(0,r.jsx)(n.code,{children:"Number"}),", etc.\nHere's how we could add the voter's name (a string) as auxiliary data:"]}),"\n",(0,r.jsx)(n.pre,{children:(0,r.jsx)(n.code,{className:"language-ts",children:"class Voter extends Struct({\n  publicKey: PublicKey,\n  votes: [Vote, Vote, Vote],\n  fullName: String\n}) {}\n"})}),"\n",(0,r.jsxs)(n.p,{children:["Again, it's important to note that this doesn't enable you to prove anything about the ",(0,r.jsx)(n.code,{children:"fullName"})," string.\nFrom the circuit point of view, it simply doesn't exist!"]}),"\n",(0,r.jsxs)(n.p,{children:[(0,r.jsx)(n.strong,{children:"Note"}),": Ensure you do not use or extend ",(0,r.jsx)(n.code,{children:"Struct"})," as a type directly. Instead, always call it as a function to construct a type. ",(0,r.jsx)(n.code,{children:"Struct"})," is not a valid provable type itself, types created with ",(0,r.jsx)(n.code,{children:"Struct(...)"})," are."]})]})}function h(e={}){const{wrapper:n}={...(0,o.R)(),...e.components};return n?(0,r.jsx)(n,{...e,children:(0,r.jsx)(a,{...e})}):a(e)}},28453:(e,n,t)=>{t.d(n,{R:()=>c,x:()=>i});var s=t(96540);const r={},o=s.createContext(r);function c(e){const n=s.useContext(o);return s.useMemo((function(){return"function"==typeof e?e(n):{...n,...e}}),[n,e])}function i(e){let n;return n=e.disableParentContext?"function"==typeof e.components?e.components(r):e.components||r:c(e.components),s.createElement(o.Provider,{value:n},e.children)}}}]);