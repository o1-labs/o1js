"use strict";(self.webpackChunkdocumentation_site=self.webpackChunkdocumentation_site||[]).push([[98203],{73845:(e,t,n)=>{n.r(t),n.d(t,{assets:()=>l,contentTitle:()=>r,default:()=>d,frontMatter:()=>s,metadata:()=>o,toc:()=>c});const o=JSON.parse('{"id":"writing-constraint-systems/zk-program","title":"Full Proof Flow with ZkProgram","description":"ZkProgram is the culmination of all the provable types, functions and constraint system tools in o1js.  This is the","source":"@site/docs/writing-constraint-systems/zk-program.mdx","sourceDirName":"writing-constraint-systems","slug":"/writing-constraint-systems/zk-program","permalink":"/o1js/writing-constraint-systems/zk-program","draft":false,"unlisted":false,"editUrl":"https://github.com/docs/writing-constraint-systems/zk-program.mdx","tags":[],"version":"current","frontMatter":{"title":"Full Proof Flow with ZkProgram"},"sidebar":"docs","previous":{"title":"Analyzing Constraints","permalink":"/o1js/writing-constraint-systems/analyzing-constraint-systems"},"next":{"title":"Serialization","permalink":"/o1js/advanced-concepts/serialization"}}');var i=n(74848),a=n(28453);n(58069);const s={title:"Full Proof Flow with ZkProgram"},r=void 0,l={},c=[{value:"Simple ZkProgram Example",id:"simple-zkprogram-example",level:2},{value:"ZkProgram with complex types",id:"zkprogram-with-complex-types",level:2}];function p(e){const t={a:"a",code:"code",h2:"h2",p:"p",pre:"pre",...(0,a.R)(),...e.components};return(0,i.jsxs)(i.Fragment,{children:[(0,i.jsxs)(t.p,{children:[(0,i.jsx)(t.code,{children:"ZkProgram"})," is the culmination of all the provable types, functions and constraint system tools in o1js.  This is the\nbuilding block that let's you actually prove and verify execution of specific code.  You can see the api reference\nfor full type information, but two features that the ",(0,i.jsx)(t.code,{children:"ZkProgram"})," gives you are access to the methods you define on\nthe system which generate a proof, and access to the ",(0,i.jsx)(t.code,{children:"verify"})," method that clients can use to verify the proof."]}),"\n",(0,i.jsx)(t.h2,{id:"simple-zkprogram-example",children:"Simple ZkProgram Example"}),"\n",(0,i.jsxs)(t.p,{children:["Every ",(0,i.jsx)(t.code,{children:"ZkProgram"})," has a name, and a set of public input and output types.  These types are shared for every method in\nthe system, so they can all generate the same kind of proof."]}),"\n",(0,i.jsxs)(t.p,{children:["Methods in the ",(0,i.jsx)(t.code,{children:"ZkProgram"})," can have custom private inputs and auxiliary output.  Private inputs are\nwhere the magic happens.  These allow you to pass in private data that you don't want to share with the verifier, and\nuse it in the proof.  Auxiliary output is more often used as a developer utility.  It is not available to the verifier,\nbut it does provide a return value to the prover.  This can be used for debugging, or tracking some metadata that's not\navailable in the public output."]}),"\n",(0,i.jsx)(t.pre,{children:(0,i.jsx)(t.code,{className:"language-ts",metastring:"file=../snippets/zk-program/zk-program.ts start=start_simple end=end_simple",children:'const SimpleZkProgram = ZkProgram({\n  name: "SimpleZkProgram",\n  publicInput: Field,\n  publicOutput: Field,\n  methods: {\n    add: {\n      privateInputs: [Field],\n      method: async (publicInput: Field, privateInput: Field) => {\n        return { publicOutput: publicInput.add(privateInput) };\n      },\n    },\n    hash: {\n      privateInputs: [Field, Field],\n      method: async (\n        publicInput: Field,\n        privateInput1: Field,\n        privateInput2: Field\n      ) => {\n        const publicOutput = Poseidon.hash([\n          publicInput,\n          privateInput1,\n          privateInput2,\n        ]);\n        return { publicOutput };\n      },\n    },\n  },\n});\n\n// usage\nawait SimpleZkProgram.compile(); // Build the constraint system\n\n// Support for different types of inputs on the same type of proof\nconst proof1 = await SimpleZkProgram.add(Field(10), Field(20));\nconst proof2 = await SimpleZkProgram.hash(Field(10), Field(20), Field(30));\n\nSimpleZkProgram.verify(proof1.proof);\nSimpleZkProgram.verify(proof2.proof);\n'})}),"\n",(0,i.jsx)(t.h2,{id:"zkprogram-with-complex-types",children:"ZkProgram with complex types"}),"\n",(0,i.jsxs)(t.p,{children:["Most real world use cases for ",(0,i.jsx)(t.code,{children:"ZkProgram"})," will involve complex data structures.  This is where you see the tangible\nbenefit of the o1js provable type APIs.  You can use any provable type as input into a ",(0,i.jsx)(t.code,{children:"ZkProgram"}),", so with tools like\n",(0,i.jsx)(t.a,{href:"/o1js/basic-types/structs",children:"Struct"}),", and ",(0,i.jsx)(t.a,{href:"/o1js/basic-types/merkle-trees#indexedmerklemap",children:"IndexedMerkleMap"}),",\nyou can model realistic data structures and easily use them as inputs in your proofs."]}),"\n",(0,i.jsx)(t.pre,{children:(0,i.jsx)(t.code,{className:"language-ts",metastring:"file=../snippets/zk-program/zk-program.ts start=start_complex end=end_complex",children:'const MAX_CANDIDATES = 8;\n\nclass Candidate extends Struct({\n  publicKey: PublicKey,\n  votes: UInt32,\n}) {}\n\nclass Election extends Struct({\n  candidates: Provable.Array(Candidate, MAX_CANDIDATES),\n  totalVotes: UInt32,\n}) {\n  /**\n   * Clone method to create a deep copy of the Election instance.\n   * This is useful to for avoiding side effects in provable code.\n   */\n  clone() {\n    return new Election({\n      candidates: this.candidates.map(\n        (candidate) => new Candidate(candidate)\n      ),\n      totalVotes: UInt32.from(this.totalVotes),\n    });\n  }\n}\n\nconst VoteProgram = ZkProgram({\n  name: "VoteProgram",\n  publicInput: Election,\n  publicOutput: Election,\n  methods: {\n    vote: {\n      privateInputs: [PublicKey],\n      method: async (election: Election, candidateKey: PublicKey) => {\n        const electionClone = election.clone();\n        for (let i = 0; i < MAX_CANDIDATES; i++) {\n          const candidate = election.candidates[i];\n          const newVotes = Provable.if(\n            candidate.publicKey.equals(candidateKey),\n            candidate.votes.add(1),\n            candidate.votes\n          );\n          electionClone.candidates[i].votes = newVotes;\n        }\n        electionClone.totalVotes = electionClone.totalVotes.add(1);\n        return {\n          publicOutput: electionClone,\n        };\n      },\n    },\n  },\n});\n\n// usage\nconst candidates = Array.from({ length: MAX_CANDIDATES }, (_, i) => {\n  return new Candidate({\n    publicKey: PrivateKey.random().toPublicKey(),\n    votes: UInt32.from(0),\n  });\n});\n\nconst election = new Election({\n  candidates,\n  totalVotes: UInt32.from(0),\n});\n\nawait VoteProgram.compile();\n\nconst voteProof = await VoteProgram.vote(election, candidates[4].publicKey);\n\nVoteProgram.verify(voteProof.proof);\n'})})]})}function d(e={}){const{wrapper:t}={...(0,a.R)(),...e.components};return t?(0,i.jsx)(t,{...e,children:(0,i.jsx)(p,{...e})}):p(e)}}}]);