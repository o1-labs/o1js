"use strict";(self.webpackChunkdocumentation_site=self.webpackChunkdocumentation_site||[]).push([[12965],{28453:(e,n,t)=>{t.d(n,{R:()=>r,x:()=>s});var o=t(96540);const a={},i=o.createContext(a);function r(e){const n=o.useContext(i);return o.useMemo((function(){return"function"==typeof e?e(n):{...n,...e}}),[n,e])}function s(e){let n;return n=e.disableParentContext?"function"==typeof e.components?e.components(a):e.components||a:r(e.components),o.createElement(i.Provider,{value:n},e.children)}},76181:(e,n,t)=>{t.r(n),t.d(n,{assets:()=>c,contentTitle:()=>s,default:()=>p,frontMatter:()=>r,metadata:()=>o,toc:()=>u});const o=JSON.parse('{"id":"advanced-concepts/recursion","title":"Recursive Zk Proofs","description":"Recursion is a powerful tool for solving complex problems with zk proofs.  Any particular constraint system will be limited by","source":"@site/docs/advanced-concepts/recursion.mdx","sourceDirName":"advanced-concepts","slug":"/advanced-concepts/recursion","permalink":"/o1js/advanced-concepts/recursion","draft":false,"unlisted":false,"editUrl":"https://github.com/docs/advanced-concepts/recursion.mdx","tags":[],"version":"current","frontMatter":{"title":"Recursive Zk Proofs","sidebar_label":"Recursion"},"sidebar":"docs","previous":{"title":"Serialization","permalink":"/o1js/advanced-concepts/serialization"},"next":{"title":"Sideloading","permalink":"/o1js/advanced-concepts/sideloaded-vks"}}');var a=t(74848),i=t(28453);const r={title:"Recursive Zk Proofs",sidebar_label:"Recursion"},s=void 0,c={},u=[{value:"Fibonacci Example",id:"fibonacci-example",level:2},{value:"Define the Fibonacci State Type",id:"define-the-fibonacci-state-type",level:3},{value:"Writing the Recursive Program",id:"writing-the-recursive-program",level:3},{value:"Using the Fibonacci Program",id:"using-the-fibonacci-program",level:3},{value:"Queue Compression Example",id:"queue-compression-example",level:2},{value:"Fill a Queue with Data",id:"fill-a-queue-with-data",level:3},{value:"Write the Recursive Program",id:"write-the-recursive-program",level:3},{value:"Using the Queue Program",id:"using-the-queue-program",level:3}];function l(e){const n={a:"a",code:"code",h2:"h2",h3:"h3",p:"p",pre:"pre",...(0,i.R)(),...e.components};return(0,a.jsxs)(a.Fragment,{children:[(0,a.jsx)(n.p,{children:"Recursion is a powerful tool for solving complex problems with zk proofs.  Any particular constraint system will be limited by\nthe lack of dynamic programming and conditional execution, but these shortcomings can be mitigated at the system architecture\nlevel with recursion."}),"\n",(0,a.jsx)(n.h2,{id:"fibonacci-example",children:"Fibonacci Example"}),"\n",(0,a.jsx)(n.p,{children:"The Fibonacci sequence is a classic example of recursion.  We can use recursive zk proofs to succinctly verify any element in\nthe sequence."}),"\n",(0,a.jsx)(n.h3,{id:"define-the-fibonacci-state-type",children:"Define the Fibonacci State Type"}),"\n",(0,a.jsxs)(n.p,{children:["First thing's first, let's define a provable type to represent the state of a Fibonacci sequence.  We'll track the index of the\nsequence, and the last two numbers in the sequence.  We'll use a ",(0,a.jsx)(n.code,{children:"Struct"})," to represent the state, and we'll add some extra\nfunctionality to the class that will be useful in the constraint system and tests."]}),"\n",(0,a.jsx)(n.pre,{children:(0,a.jsx)(n.code,{className:"language-ts",metastring:"file=../snippets/recursion/recursion.ts start=start_fibonacci_state end=end_fibonacci_state",children:"class FibonacciState extends Struct({\n  index: UInt32,\n  n_1: UInt32,\n  n_2: UInt32,\n}) {\n  static empty() {\n    return new FibonacciState({\n      index: UInt32.zero,\n      n_1: UInt32.zero,\n      n_2: UInt32.zero,\n    });\n  }\n  assertEquals(other: FibonacciState) {\n    this.index.assertEquals(other.index);\n    this.n_1.assertEquals(other.n_1);\n    this.n_2.assertEquals(other.n_2);\n  }\n}\n\n"})}),"\n",(0,a.jsx)(n.h3,{id:"writing-the-recursive-program",children:"Writing the Recursive Program"}),"\n",(0,a.jsx)(n.p,{children:"With the state data type defined, we can move on to writing a recursive program to prove execution of the Fibonacci sequence.\nThe program needs two methods: one to represent the base case, and one to represent the recursive case.  The two reasons for\nwhich we need a base case are: 1. to generate a proof when we don't have a previous one to build off of, and 2. to prove that\nall other proofs are built off of the same base case."}),"\n",(0,a.jsx)(n.pre,{children:(0,a.jsx)(n.code,{className:"language-ts",metastring:"file=../snippets/recursion/recursion.ts start=start_fibonacci_program end=end_fibonacci_program",children:'const Fibonacci = ZkProgram({\n  name: "Fibonacci",\n  publicInput: FibonacciState,\n  publicOutput: FibonacciState,\n\n  methods: {\n    base: {\n      privateInputs: [],\n      method: async (_: FibonacciState) => {\n        return {\n          publicOutput: new FibonacciState({\n            index: UInt32.from(1),\n            n_1: UInt32.from(1),\n            n_2: UInt32.from(1),\n          }),\n        };\n      },\n    },\n    recursive: {\n      privateInputs: [SelfProof],\n      method: async (\n        input: FibonacciState,\n        // Note that the `SelfProof` syntax here means that the proof has public input: FibonacciState and public output: FibonacciState\n        previousProof: SelfProof<FibonacciState, FibonacciState>\n      ) => {\n        // Assert that the public input to this method matches the public output of the previous proof\n        input.assertEquals(previousProof.publicOutput);\n        // Verify the previous proof\n        previousProof.verify();\n\n        // Return the next Fibonacci number\n        return {\n          publicOutput: new FibonacciState({\n            index: input.index.add(1),\n            n_1: input.n_1.add(input.n_2),\n            n_2: input.n_1,\n          }),\n        };\n      },\n    },\n  },\n});\n'})}),"\n",(0,a.jsxs)(n.p,{children:["For more details on ",(0,a.jsx)(n.code,{children:"SelfProof"}),", check out the ",(0,a.jsx)(n.a,{href:"/o1js/api-reference/classes/SelfProof",children:"api reference"}),"."]}),"\n",(0,a.jsx)(n.h3,{id:"using-the-fibonacci-program",children:"Using the Fibonacci Program"}),"\n",(0,a.jsx)(n.p,{children:"Now that we have a program, we can use it to generate proofs.  Here is some example code showing how to generate a proof and\ninteract with it recursively."}),"\n",(0,a.jsx)(n.pre,{children:(0,a.jsx)(n.code,{className:"language-ts",metastring:"file=../snippets/recursion/recursion.ts start=start_fibonacci_usage end=end_fibonacci_usage",children:"await Fibonacci.compile();\nconst proof1 = await Fibonacci.base(FibonacciState.empty());\nconst proof2 = await Fibonacci.recursive(\n  proof1.proof.publicOutput,\n  proof1.proof\n);\nconst proof3 = await Fibonacci.recursive(\n  proof2.proof.publicOutput,\n  proof2.proof\n);\nconst proof4 = await Fibonacci.recursive(\n  proof3.proof.publicOutput,\n  proof3.proof\n);\nconst proof5 = await Fibonacci.recursive(\n  proof4.proof.publicOutput,\n  proof4.proof\n);\n"})}),"\n",(0,a.jsx)(n.h2,{id:"queue-compression-example",children:"Queue Compression Example"}),"\n",(0,a.jsx)(n.p,{children:"For a more realistic example, let's say that we have an application with some queue of events to process, and we want to\nprovably process them in a batch.  In the example below, let's say we just want to compute the sum, but also prove that\nprocessed the entire queue."}),"\n",(0,a.jsx)(n.h3,{id:"fill-a-queue-with-data",children:"Fill a Queue with Data"}),"\n",(0,a.jsx)(n.p,{children:"In this example, the queue will look a little like a blockchain.  Each event will include a value and a hash of the value\nand the previous event hash.  That way we can prove that we've processed the queue in order."}),"\n",(0,a.jsx)(n.pre,{children:(0,a.jsx)(n.code,{className:"language-ts",metastring:"file=../snippets/recursion/recursion.ts start=start_queue_data end=end_queue_data",children:"let lastHash = Poseidon.hash([UInt32.zero.value]);\nconst blocks = [{ value: UInt32.zero, hash: lastHash }];\nfor (let i = 0; i < 3; i++) {\n  const value = UInt32.from(Math.floor(Math.random() * 100));\n  const block = { value, hash: Poseidon.hash([lastHash, value.value]) };\n  blocks.push(block);\n  lastHash = block.hash;\n}\n"})}),"\n",(0,a.jsx)(n.h3,{id:"write-the-recursive-program",children:"Write the Recursive Program"}),"\n",(0,a.jsx)(n.p,{children:"For the program, we need a data type like in the Fibonacci example.  In this case, we'll want to track the running sum,\nthe starting hash of the proof range, and the latest hash that has been processed.  Like in the Fibonacci\nexample, we'll need a base case and a recursive case.  The base case will be a sum of 0 and a hash of 0, and the\nrecursive case will add one value to the running sum and update the hashes."}),"\n",(0,a.jsx)(n.pre,{children:(0,a.jsx)(n.code,{className:"language-ts",metastring:"file=../snippets/recursion/recursion.ts start=start_queue_program end=end_queue_program",children:'class BlockProofOutputs extends Struct({\n  currentSum: UInt32,\n  startingHash: Field,\n  endingHash: Field,\n}) {}\n\nconst SumBlocks = ZkProgram({\n  name: "SumBlocks",\n  publicInput: UInt32,\n  publicOutput: BlockProofOutputs,\n\n  methods: {\n    base: {\n      privateInputs: [],\n      method: async (_: UInt32) => {\n        return {\n          publicOutput: new BlockProofOutputs({\n            currentSum: UInt32.zero,\n            startingHash: Poseidon.hash([UInt32.zero.value]),\n            endingHash: Poseidon.hash([UInt32.zero.value]),\n          }),\n        };\n      },\n    },\n    addNext: {\n      privateInputs: [SelfProof],\n      method: async (\n        input: UInt32,\n        previousProof: SelfProof<UInt32, BlockProofOutputs>\n      ) => {\n        previousProof.verify();\n\n        return {\n          publicOutput: new BlockProofOutputs({\n            currentSum: previousProof.publicOutput.currentSum.add(input),\n            startingHash: previousProof.publicOutput.startingHash,\n            endingHash: Poseidon.hash([\n              previousProof.publicOutput.endingHash,\n              input.value,\n            ]),\n          }),\n        };\n      },\n    },\n  },\n});\n'})}),"\n",(0,a.jsx)(n.h3,{id:"using-the-queue-program",children:"Using the Queue Program"}),"\n",(0,a.jsx)(n.p,{children:"Here's how you would use the queue program to generate a proof."}),"\n",(0,a.jsx)(n.pre,{children:(0,a.jsx)(n.code,{className:"language-ts",metastring:"file=../snippets/recursion/recursion.ts start=start_queue_usage end=end_queue_usage",children:"await SumBlocks.compile();\n\nconst baseProof = await SumBlocks.base(UInt32.zero);\nlet proof = baseProof;\nfor (let i = 1; i < blocks.length; i++) {\n  const block = blocks[i];\n  const nextProof = await SumBlocks.addNext(block.value, proof.proof);\n  proof = nextProof;\n}\n\n"})})]})}function p(e={}){const{wrapper:n}={...(0,i.R)(),...e.components};return n?(0,a.jsx)(n,{...e,children:(0,a.jsx)(l,{...e})}):l(e)}}}]);