"use strict";(self.webpackChunkdocumentation_site=self.webpackChunkdocumentation_site||[]).push([[56820],{28352:(e,s,n)=>{n.r(s),n.d(s,{assets:()=>l,contentTitle:()=>c,default:()=>o,frontMatter:()=>a,metadata:()=>i,toc:()=>h});const i=JSON.parse('{"id":"api-reference/variables/Keccak","title":"Keccak","description":"Defined in11","source":"@site/docs/api-reference/variables/Keccak.mdx","sourceDirName":"api-reference/variables","slug":"/api-reference/variables/Keccak","permalink":"/o1js/api-reference/variables/Keccak","draft":false,"unlisted":false,"editUrl":"https://github.com/docs/api-reference/variables/Keccak.mdx","tags":[],"version":"current","frontMatter":{},"sidebar":"docs","previous":{"title":"Hash","permalink":"/o1js/api-reference/variables/Hash"},"next":{"title":"Permissions","permalink":"/o1js/api-reference/variables/Permissions"}}');var r=n(74848),t=n(28453);const a={},c=void 0,l={},h=[{value:"Type declaration",id:"type-declaration",level:2},{value:"ethereum()",id:"ethereum",level:3},{value:"Parameters",id:"parameters",level:4},{value:"message",id:"message",level:5},{value:"Returns",id:"returns",level:4},{value:"nistSha3()",id:"nistsha3",level:3},{value:"Parameters",id:"parameters-1",level:4},{value:"len",id:"len",level:5},{value:"message",id:"message-1",level:5},{value:"Returns",id:"returns-1",level:4},{value:"preNist()",id:"prenist",level:3},{value:"Parameters",id:"parameters-2",level:4},{value:"len",id:"len-1",level:5},{value:"message",id:"message-2",level:5},{value:"Returns",id:"returns-2",level:4}];function d(e){const s={a:"a",code:"code",h2:"h2",h3:"h3",h4:"h4",h5:"h5",p:"p",pre:"pre",...(0,t.R)(),...e.components};return(0,r.jsxs)(r.Fragment,{children:[(0,r.jsx)(s.pre,{children:(0,r.jsx)(s.code,{className:"language-ts",children:"const Keccak: {\n  ethereum: Bytes;\n  nistSha3: Bytes;\n  preNist: Bytes;\n};\n"})}),"\n",(0,r.jsxs)(s.p,{children:["Defined in: ",(0,r.jsx)(s.a,{href:"https://github.com/o1-labs/o1js/blob/df1ff77af12d7cbbed4a6167f02815fad4f0dceb/src/lib/provable/crypto/keccak.ts#L11",children:"lib/provable/crypto/keccak.ts:11"})]}),"\n",(0,r.jsx)(s.h2,{id:"type-declaration",children:"Type declaration"}),"\n",(0,r.jsx)(s.h3,{id:"ethereum",children:"ethereum()"}),"\n",(0,r.jsxs)(s.p,{children:["Ethereum-Compatible Keccak-256 Hash Function.\nThis is a specialized variant of ",(0,r.jsx)(s.a,{href:"/o1js/api-reference/variables/Keccak#prenist",children:"Keccak.preNist"})," configured for a 256-bit output length."]}),"\n",(0,r.jsx)(s.p,{children:"Primarily used in Ethereum for hashing transactions, messages, and other types of payloads."}),"\n",(0,r.jsxs)(s.p,{children:["The function accepts ",(0,r.jsx)(s.a,{href:"/o1js/api-reference/functions/Bytes",children:"Bytes"})," as the input message, which is a type that represents a static-length list of byte-sized field elements (range-checked using ",(0,r.jsx)(s.a,{href:"/o1js/api-reference/variables/Gadgets#rangecheck8",children:"Gadgets.rangeCheck8"}),").\nAlternatively, you can pass plain ",(0,r.jsx)(s.code,{children:"number[]"})," of ",(0,r.jsx)(s.code,{children:"Uint8Array"})," to perform a hash outside provable code."]}),"\n",(0,r.jsxs)(s.p,{children:["Produces an output of ",(0,r.jsx)(s.a,{href:"/o1js/api-reference/functions/Bytes",children:"Bytes"})," of length 32. Both input and output bytes are big-endian."]}),"\n",(0,r.jsx)(s.h4,{id:"parameters",children:"Parameters"}),"\n",(0,r.jsx)(s.h5,{id:"message",children:"message"}),"\n",(0,r.jsx)(s.p,{children:(0,r.jsx)(s.a,{href:"/o1js/api-reference/type-aliases/FlexibleBytes",children:(0,r.jsx)(s.code,{children:"FlexibleBytes"})})}),"\n",(0,r.jsxs)(s.p,{children:["Big-endian ",(0,r.jsx)(s.a,{href:"/o1js/api-reference/functions/Bytes",children:"Bytes"})," representing the message to hash."]}),"\n",(0,r.jsx)(s.pre,{children:(0,r.jsx)(s.code,{className:"language-ts",children:'let preimage = Bytes.fromString("hello world");\nlet digest = Keccak.ethereum(preimage);\n'})}),"\n",(0,r.jsx)(s.h4,{id:"returns",children:"Returns"}),"\n",(0,r.jsx)(s.p,{children:(0,r.jsx)(s.code,{children:"Bytes"})}),"\n",(0,r.jsx)(s.h3,{id:"nistsha3",children:"nistSha3()"}),"\n",(0,r.jsxs)(s.p,{children:["Implementation of ",(0,r.jsx)(s.a,{href:"https://csrc.nist.gov/pubs/fips/202/final",children:"NIST SHA-3"})," Hash Function.\nSupports output lengths of 256, 384, or 512 bits."]}),"\n",(0,r.jsxs)(s.p,{children:["Applies the SHA-3 hash function to a list of big-endian byte-sized ",(0,r.jsx)(s.a,{href:"/o1js/api-reference/classes/Field",children:"Field"})," elements, flexible to handle varying output lengths (256, 384, 512 bits) as specified."]}),"\n",(0,r.jsxs)(s.p,{children:["The function accepts ",(0,r.jsx)(s.a,{href:"/o1js/api-reference/functions/Bytes",children:"Bytes"})," as the input message, which is a type that represents a static-length list of byte-sized field elements (range-checked using ",(0,r.jsx)(s.a,{href:"/o1js/api-reference/variables/Gadgets#rangecheck8",children:"Gadgets.rangeCheck8"}),").\nAlternatively, you can pass plain ",(0,r.jsx)(s.code,{children:"number[]"})," of ",(0,r.jsx)(s.code,{children:"Uint8Array"})," to perform a hash outside provable code."]}),"\n",(0,r.jsxs)(s.p,{children:["Produces an output of ",(0,r.jsx)(s.a,{href:"/o1js/api-reference/functions/Bytes",children:"Bytes"})," that conforms to the chosen bit length.\nBoth input and output bytes are big-endian."]}),"\n",(0,r.jsx)(s.h4,{id:"parameters-1",children:"Parameters"}),"\n",(0,r.jsx)(s.h5,{id:"len",children:"len"}),"\n",(0,r.jsx)(s.p,{children:"Desired output length in bits. Valid options: 256, 384, 512."}),"\n",(0,r.jsxs)(s.p,{children:[(0,r.jsx)(s.code,{children:"256"})," | ",(0,r.jsx)(s.code,{children:"384"})," | ",(0,r.jsx)(s.code,{children:"512"})]}),"\n",(0,r.jsx)(s.h5,{id:"message-1",children:"message"}),"\n",(0,r.jsx)(s.p,{children:(0,r.jsx)(s.a,{href:"/o1js/api-reference/type-aliases/FlexibleBytes",children:(0,r.jsx)(s.code,{children:"FlexibleBytes"})})}),"\n",(0,r.jsxs)(s.p,{children:["Big-endian ",(0,r.jsx)(s.a,{href:"/o1js/api-reference/functions/Bytes",children:"Bytes"})," representing the message to hash."]}),"\n",(0,r.jsx)(s.pre,{children:(0,r.jsx)(s.code,{className:"language-ts",children:'let preimage = Bytes.fromString("hello world");\nlet digest256 = Keccak.nistSha3(256, preimage);\nlet digest384 = Keccak.nistSha3(384, preimage);\nlet digest512 = Keccak.nistSha3(512, preimage);\n'})}),"\n",(0,r.jsx)(s.h4,{id:"returns-1",children:"Returns"}),"\n",(0,r.jsx)(s.p,{children:(0,r.jsx)(s.code,{children:"Bytes"})}),"\n",(0,r.jsx)(s.h3,{id:"prenist",children:"preNist()"}),"\n",(0,r.jsxs)(s.p,{children:["Implementation of ",(0,r.jsx)(s.a,{href:"https://keccak.team/keccak.html",children:"pre-NIST Keccak"})," hash function.\nSupports output lengths of 256, 384, or 512 bits."]}),"\n",(0,r.jsxs)(s.p,{children:["Keccak won the SHA-3 competition and was slightly altered before being standardized as SHA-3 by NIST in 2015.\nThis variant was used in Ethereum before the NIST standardization, by specifying ",(0,r.jsx)(s.code,{children:"len"})," as 256 bits you can obtain the same hash function as used by Ethereum ",(0,r.jsx)(s.a,{href:"/o1js/api-reference/variables/Keccak#ethereum",children:"Keccak.ethereum"}),"."]}),"\n",(0,r.jsxs)(s.p,{children:["The function applies the pre-NIST Keccak hash function to a list of byte-sized ",(0,r.jsx)(s.a,{href:"/o1js/api-reference/classes/Field",children:"Field"})," elements and is flexible to handle varying output lengths (256, 384, 512 bits) as specified."]}),"\n",(0,r.jsxs)(s.p,{children:[(0,r.jsx)(s.a,{href:"/o1js/api-reference/variables/Keccak#prenist",children:"Keccak.preNist"})," accepts ",(0,r.jsx)(s.a,{href:"/o1js/api-reference/functions/Bytes",children:"Bytes"})," as the input message, which is a type that represents a static-length list of byte-sized field elements (range-checked using ",(0,r.jsx)(s.a,{href:"/o1js/api-reference/variables/Gadgets#rangecheck8",children:"Gadgets.rangeCheck8"}),").\nAlternatively, you can pass plain ",(0,r.jsx)(s.code,{children:"number[]"})," of ",(0,r.jsx)(s.code,{children:"Uint8Array"})," to perform a hash outside provable code."]}),"\n",(0,r.jsxs)(s.p,{children:["Produces an output of ",(0,r.jsx)(s.a,{href:"/o1js/api-reference/functions/Bytes",children:"Bytes"})," that conforms to the chosen bit length.\nBoth input and output bytes are big-endian."]}),"\n",(0,r.jsx)(s.h4,{id:"parameters-2",children:"Parameters"}),"\n",(0,r.jsx)(s.h5,{id:"len-1",children:"len"}),"\n",(0,r.jsx)(s.p,{children:"Desired output length in bits. Valid options: 256, 384, 512."}),"\n",(0,r.jsxs)(s.p,{children:[(0,r.jsx)(s.code,{children:"256"})," | ",(0,r.jsx)(s.code,{children:"384"})," | ",(0,r.jsx)(s.code,{children:"512"})]}),"\n",(0,r.jsx)(s.h5,{id:"message-2",children:"message"}),"\n",(0,r.jsx)(s.p,{children:(0,r.jsx)(s.a,{href:"/o1js/api-reference/type-aliases/FlexibleBytes",children:(0,r.jsx)(s.code,{children:"FlexibleBytes"})})}),"\n",(0,r.jsxs)(s.p,{children:["Big-endian ",(0,r.jsx)(s.a,{href:"/o1js/api-reference/functions/Bytes",children:"Bytes"})," representing the message to hash."]}),"\n",(0,r.jsx)(s.pre,{children:(0,r.jsx)(s.code,{className:"language-ts",children:'let preimage = Bytes.fromString("hello world");\nlet digest256 = Keccak.preNist(256, preimage);\nlet digest384 = Keccak.preNist(384, preimage);\nlet digest512= Keccak.preNist(512, preimage);\n'})}),"\n",(0,r.jsx)(s.h4,{id:"returns-2",children:"Returns"}),"\n",(0,r.jsx)(s.p,{children:(0,r.jsx)(s.code,{children:"Bytes"})})]})}function o(e={}){const{wrapper:s}={...(0,t.R)(),...e.components};return s?(0,r.jsx)(s,{...e,children:(0,r.jsx)(d,{...e})}):d(e)}},28453:(e,s,n)=>{n.d(s,{R:()=>a,x:()=>c});var i=n(96540);const r={},t=i.createContext(r);function a(e){const s=i.useContext(t);return i.useMemo((function(){return"function"==typeof e?e(s):{...s,...e}}),[s,e])}function c(e){let s;return s=e.disableParentContext?"function"==typeof e.components?e.components(r):e.components||r:a(e.components),i.createElement(t.Provider,{value:s},e.children)}}}]);