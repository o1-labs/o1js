#!/usr/bin/env node
/**
 * Examples of security vulnerabilities that property-based tests would catch
 * 
 * WARNING: This file contains intentionally vulnerable code for demonstration.
 * DO NOT use any of this code in production!
 */

import { Field, Provable, Gadgets, Bool } from './dist/node/index.js';

console.log('üîç Demonstrating Security Vulnerabilities PBTs Would Catch\n');

// Vulnerability 1: Timing Attack in Field Operations
console.log('1. TIMING ATTACK VULNERABILITY');
console.log('   Vulnerable implementation that leaks information through timing:');

function vulnerableIsZero(field) {
  // BAD: Early return creates timing difference
  if (field.toBigInt() === 0n) {
    return true;
  }
  
  // Simulate some computation
  let dummy = field;
  for (let i = 0; i < 100; i++) {
    dummy = dummy.add(Field(1));
  }
  return false;
}

// Demonstrate timing difference
const zero = Field(0);
const nonZero = Field(42);

console.time('zero check');
vulnerableIsZero(zero);
console.timeEnd('zero check');

console.time('non-zero check');
vulnerableIsZero(nonZero);
console.timeEnd('non-zero check');

console.log('   ‚ö†Ô∏è  Notice the timing difference - this leaks whether input is zero!\n');

// Vulnerability 2: Non-Canonical Field Representation
console.log('2. NON-CANONICAL REPRESENTATION VULNERABILITY');
console.log('   Vulnerable implementation that accepts multiple representations:');

function vulnerableFieldCreation(value) {
  // BAD: Not reducing modulo p
  return { value: value };
}

const fieldModulus = Field.ORDER;
const a = vulnerableFieldCreation(42n);
const b = vulnerableFieldCreation(42n + fieldModulus);

console.log(`   Field a: ${a.value}`);
console.log(`   Field b: ${b.value}`);
console.log(`   Are they equal? ${a.value === b.value} (should be true!)`);
console.log('   ‚ö†Ô∏è  Multiple representations break uniqueness assumptions!\n');

// Vulnerability 3: Witness Extraction
console.log('3. WITNESS EXTRACTION VULNERABILITY');
console.log('   Vulnerable constraint that exposes secret witness:');

Provable.runAndCheck(() => {
  const secret = Provable.witness(Field, () => Field(12345));
  const public1 = Field(1);
  
  // BAD: Constraint that directly exposes witness
  // secret * 1 = secret (trivial constraint)
  const leaked = secret.mul(public1);
  
  console.log(`   Public sees: ${leaked.toString()}`);
  console.log('   ‚ö†Ô∏è  Secret witness value exposed through trivial constraint!\n');
});

// Vulnerability 4: Constraint Malleability
console.log('4. CONSTRAINT MALLEABILITY VULNERABILITY');
console.log('   Vulnerable system that allows constraint manipulation:');

class VulnerableConstraintSystem {
  constructor() {
    this.constraints = [];
  }
  
  addConstraint(constraint) {
    // BAD: No validation or canonicalization
    this.constraints.push(constraint);
  }
  
  // BAD: Allows modification after creation
  getConstraints() {
    return this.constraints;
  }
}

const vcs = new VulnerableConstraintSystem();
vcs.addConstraint({ type: 'equal', left: 'x', right: 'y' });

// Attacker modifies constraints
vcs.getConstraints()[0].right = 'z';

console.log('   Original constraint: x = y');
console.log('   Modified constraint:', vcs.getConstraints()[0]);
console.log('   ‚ö†Ô∏è  Constraints can be modified after creation!\n');

// Vulnerability 5: Integer Overflow in Range Check
console.log('5. INTEGER OVERFLOW IN RANGE CHECK');
console.log('   Vulnerable range check implementation:');

function vulnerableRangeCheck(value, bits) {
  // BAD: Using JavaScript number loses precision
  const maxValue = Math.pow(2, bits) - 1;
  const numValue = Number(value.toBigInt());
  
  if (numValue <= maxValue) {
    console.log(`   ‚úì ${numValue} fits in ${bits} bits`);
    return true;
  } else {
    console.log(`   ‚úó ${numValue} doesn't fit in ${bits} bits`);
    return false;
  }
}

// This should fail but might pass due to precision loss
const largeValue = Field(2n ** 53n + 1n);
vulnerableRangeCheck(largeValue, 32);
console.log('   ‚ö†Ô∏è  Precision loss in number conversion breaks range checks!\n');

// Vulnerability 6: Hash Collision Attack
console.log('6. WEAK HASH FUNCTION VULNERABILITY');
console.log('   Vulnerable hash with predictable collisions:');

function vulnerableHash(input) {
  // BAD: Weak hash function
  const value = input.toBigInt();
  // Simple modular hash - many collisions!
  return Field(value % 1000n);
}

const input1 = Field(1234);
const input2 = Field(2234);
const hash1 = vulnerableHash(input1);
const hash2 = vulnerableHash(input2);

console.log(`   Hash(${input1}): ${hash1}`);
console.log(`   Hash(${input2}): ${hash2}`);
console.log(`   Collision: ${hash1.equals(hash2)}`);
console.log('   ‚ö†Ô∏è  Weak hash function allows finding collisions!\n');

// Vulnerability 7: Side-Channel Through Exceptions
console.log('7. EXCEPTION SIDE-CHANNEL VULNERABILITY');
console.log('   Vulnerable code that leaks information through errors:');

function vulnerableDivision(a, b, secret) {
  try {
    if (secret.equals(Field(42))) {
      throw new Error(`Secret value is 42!`);
    }
    return a.div(b);
  } catch (e) {
    // BAD: Error message leaks secret
    throw e;
  }
}

try {
  vulnerableDivision(Field(10), Field(2), Field(42));
} catch (e) {
  console.log(`   Error caught: ${e.message}`);
  console.log('   ‚ö†Ô∏è  Error message leaks secret value!\n');
}

// Summary
console.log('=== SUMMARY ===');
console.log('These vulnerabilities would be caught by property-based tests:');
console.log('1. Timing attacks - PBTs measure timing variance');
console.log('2. Non-canonical representation - PBTs verify uniqueness');
console.log('3. Witness extraction - PBTs check witness privacy');
console.log('4. Constraint malleability - PBTs verify immutability');
console.log('5. Integer overflow - PBTs test with large values');
console.log('6. Weak hashing - PBTs check collision resistance');
console.log('7. Side-channels - PBTs analyze error messages');
console.log('\nRun ./run-security-tests.sh to verify Sparky is protected against these!');