import { mapTuple } from './util.js';
import { affineFromRust, affineToRust, fieldsFromRustFlat, fieldsToRustFlat, } from './conversion-base.js';
export { conversionCore, freeOnFinalize, wrap, unwrap, mapFromUintArray, mapToUint32Array, };
function conversionCore(wasm) {
    const fp = conversionCorePerField(wasm, {
        CommitmentCurve: wasm.WasmGVesta,
        makeAffine: wasm.caml_vesta_affine_one,
        Gate: wasm.WasmFpGate,
        PolyComm: wasm.WasmFpPolyComm,
    });
    const fq = conversionCorePerField(wasm, {
        CommitmentCurve: wasm.WasmGPallas,
        makeAffine: wasm.caml_pallas_affine_one,
        Gate: wasm.WasmFqGate,
        PolyComm: wasm.WasmFqPolyComm,
    });
    return {
        fp,
        fq,
        wireToRust: fp.wireToRust, // doesn't depend on the field
        mapMlArrayToRustVector([, ...array], map) {
            return mapToUint32Array(array, (x) => unwrap(map(x)));
        },
    };
}
function conversionCorePerField(wasm, { CommitmentCurve, makeAffine, Gate, PolyComm }) {
    let self = {
        wireToRust([, row, col]) {
            return wasm.Wire.create(row, col);
        },
        vectorToRust: fieldsToRustFlat,
        vectorFromRust: fieldsFromRustFlat,
        gateToRust(gate) {
            let [, typ, [, ...wires], coeffs] = gate;
            let rustWires = new wasm.WasmGateWires(...mapTuple(wires, self.wireToRust));
            let rustCoeffs = fieldsToRustFlat(coeffs);
            return new Gate(typ, rustWires, rustCoeffs);
        },
        gateFromRust(wasmGate) {
            // note: this was never used and the old implementation was wrong
            // (accessed non-existent fields on wasmGate)
            throw Error('gateFromRust not implemented');
        },
        pointToRust(point) {
            return affineToRust(point, makeAffine);
        },
        pointFromRust: affineFromRust,
        pointsToRust([, ...points]) {
            return mapToUint32Array(points, (point) => unwrap(self.pointToRust(point)));
        },
        pointsFromRust(points) {
            let arr = mapFromUintArray(points, (ptr) => affineFromRust(wrap(ptr, CommitmentCurve)));
            return [0, ...arr];
        },
        polyCommToRust(polyComm) {
            let [, camlElems] = polyComm;
            let rustShifted = undefined;
            let rustUnshifted = self.pointsToRust(camlElems);
            return new PolyComm(rustUnshifted, rustShifted);
        },
        polyCommFromRust(polyComm) {
            let rustUnshifted = polyComm.unshifted;
            let mlUnshifted = mapFromUintArray(rustUnshifted, (ptr) => {
                return affineFromRust(wrap(ptr, CommitmentCurve));
            });
            return [0, [0, ...mlUnshifted]];
        },
        polyCommsToRust([, ...comms]) {
            return mapToUint32Array(comms, (c) => unwrap(self.polyCommToRust(c)));
        },
        polyCommsFromRust(rustComms) {
            let comms = mapFromUintArray(rustComms, (ptr) => self.polyCommFromRust(wrap(ptr, PolyComm)));
            return [0, ...comms];
        },
    };
    return self;
}
function wrap(ptr, Class) {
    const obj = Object.create(Class.prototype);
    obj.__wbg_ptr = ptr;
    return obj;
}
function unwrap(obj) {
    // Beware: caller may need to do finalizer things to avoid these
    // pointers disappearing out from under us.
    let ptr = obj.__wbg_ptr;
    if (ptr === undefined)
        throw Error('unwrap: missing ptr');
    return ptr;
}
const registry = new FinalizationRegistry((ptr) => {
    ptr.free();
});
function freeOnFinalize(instance) {
    // This is an unfortunate hack: we're creating a second instance of the
    // class to be able to call free on it. We can't pass the value itself,
    // since the registry holds a strong reference to the representative value.
    //
    // However, the class is only really a wrapper around a pointer, with a
    // reference to the class' prototype as its __prototype__.
    //
    // It might seem cleaner to call the destructor here on the pointer
    // directly, but unfortunately the destructor name is some mangled internal
    // string generated by wasm_bindgen. For now, this is the best,
    // least-brittle way to free once the original class instance gets collected.
    let instanceRepresentative = wrap(instance.__wbg_ptr, instance.constructor);
    registry.register(instance, instanceRepresentative, instance);
    return instance;
}
function mapFromUintArray(array, map) {
    let n = array.length;
    let result = Array(n);
    for (let i = 0; i < n; i++) {
        result[i] = map(array[i]);
    }
    return result;
}
function mapToUint32Array(array, map) {
    let n = array.length;
    let result = new Uint32Array(n);
    for (let i = 0; i < n; i++) {
        result[i] = map(array[i]);
    }
    return result;
}
