/**
 * Constraint System JSON Comparison Test Suite
 * 
 * Compares the full JSON representation of constraint systems generated by
 * Snarky and Sparky backends to ensure complete parity at the constraint level.
 * 
 * Created: January 5, 2025, 00:15 UTC
 * Last Modified: January 5, 2025, 00:15 UTC
 */

import { Field, Bool, Poseidon, Provable, UInt32, UInt64, Group, CircuitString } from '../../../../index.js';
import { Snarky, initializeBindings } from '../../../../bindings.js';

export interface ConstraintJSONTestCase {
  name: string;
  type: 'comparison';
  testFn: (backend?: string) => Promise<any>;
  compareBy: 'json';
  timeout?: number;
}

/**
 * Deep comparison utilities for constraint system JSON
 */
class ConstraintSystemJSONComparer {
  /**
   * Get constraint system as JSON for a circuit operation
   */
  static async getConstraintSystemJSON<T extends any[]>(
    operation: (...inputs: T) => any,
    inputs: T,
    operationName: string,
    backend?: string
  ) {
    try {
      // Run the operation to generate constraint system
      const cs = await Provable.constraintSystem(() => {
        // Create witness variables from inputs
        const witnessInputs = inputs.map((input) => {
          if (input instanceof Field) {
            return Provable.witness(Field, () => input);
          } else if (input instanceof Bool) {
            return Provable.witness(Bool, () => input);
          } else if (input instanceof UInt32) {
            return Provable.witness(UInt32, () => input);
          } else if (input instanceof UInt64) {
            return Provable.witness(UInt64, () => input);
          } else if (input instanceof Group) {
            return Provable.witness(Group, () => input);
          } else if (typeof input === 'number') {
            return Provable.witness(Field, () => Field(input));
          } else if (typeof input === 'bigint') {
            return Provable.witness(Field, () => Field(input));
          } else {
            // Try to witness as Field by default
            return Provable.witness(Field, () => Field(input));
          }
        }) as T;
        
        // Execute the operation
        const result = operation(...witnessInputs);
        
        // Ensure result is constrained (helps reveal all constraints)
        if (result instanceof Field) {
          result.assertEquals(result);
        } else if (result instanceof Bool) {
          result.assertEquals(result);
        } else if (result && typeof result === 'object' && 'assertEquals' in result) {
          (result as any).assertEquals(result);
        }
        
        return result;
      });

      // Convert constraint system to JSON
      // Ensure bindings are initialized
      await initializeBindings(backend);
      
      // Access Snarky methods
      const snarky = (global as any).Snarky || Snarky;
      
      // For Sparky backend, the constraint system is already in a JSON-friendly format
      let json;
      if (backend === 'sparky') {
        // Sparky's constraint system already has gates in the right format
        // We need to extract the JSON representation
        if (cs.gates && Array.isArray(cs.gates)) {
          json = {
            gates: cs.gates,
            public_input_size: cs.publicInputSize || 0
          };
        } else {
          // Try to call toJson if available
          try {
            if (snarky && snarky.constraintSystem && snarky.constraintSystem.toJson) {
              json = snarky.constraintSystem.toJson(cs);
            } else {
              throw new Error('Unable to convert Sparky constraint system to JSON');
            }
          } catch (e) {
            // If toJson fails, construct from available data
            json = {
              gates: [],
              public_input_size: cs.publicInputSize || 0
            };
          }
        }
      } else {
        // For Snarky backend, handle the known toJson issue
        if (cs.gates !== undefined && typeof cs.gates === 'number' && cs.gates === 0) {
          // Empty constraint system - no gates
          json = {
            gates: [],
            public_input_size: cs.publicInputSize || 0
          };
        } else if (snarky && snarky.constraintSystem && snarky.constraintSystem.toJson) {
          try {
            json = snarky.constraintSystem.toJson(cs);
          } catch (e) {
            // Handle the toJson error gracefully
            console.warn(`toJson failed for ${operationName} on ${backend}, using fallback`);
            // Extract what we can from the constraint system
            json = {
              gates: [],
              public_input_size: cs.publicInputSize || 0,
              error: 'toJson conversion failed'
            };
          }
        } else {
          // Fallback
          json = {
            gates: [],
            public_input_size: cs.publicInputSize || 0
          };
        }
      }
      
      // Normalize the JSON for comparison
      const normalized = this.normalizeConstraintJSON(json);
      
      return {
        success: true,
        json: normalized,
        stats: {
          gateCount: normalized.gates.length,
          publicInputSize: normalized.public_input_size,
          gateTypes: this.getGateTypeDistribution(normalized)
        }
      };
      
    } catch (error) {
      const errorMessage = error instanceof Error ? error.message : String(error);
      console.warn(`Failed to get constraint system JSON for ${operationName} on ${backend}:`, errorMessage);
      
      return {
        success: false,
        error: errorMessage,
        json: null,
        stats: null
      };
    }
  }
  
  /**
   * Normalize constraint system JSON for comparison
   * Handles differences in formatting between backends
   */
  static normalizeConstraintJSON(json: any): any {
    if (!json) return null;
    
    // Handle both 'gates' and 'constraints' field names (Sparky might use either)
    const gates = json.gates || json.constraints || [];
    
    // Normalize each gate
    const normalizedGates = gates.map((gate: any) => {
      // Normalize wire representation
      const normalizedWires = (gate.wires || []).map((wire: any) => ({
        row: typeof wire.row === 'number' ? wire.row : parseInt(wire.row),
        col: typeof wire.col === 'number' ? wire.col : parseInt(wire.col)
      }));
      
      // Normalize coefficients (ensure they're strings)
      const normalizedCoeffs = (gate.coeffs || []).map((coeff: any) => 
        typeof coeff === 'string' ? coeff : String(coeff)
      );
      
      return {
        typ: gate.typ || gate.type,
        wires: normalizedWires,
        coeffs: normalizedCoeffs
      };
    });
    
    return {
      gates: normalizedGates,
      public_input_size: json.public_input_size || 0
    };
  }
  
  /**
   * Get distribution of gate types in constraint system
   */
  static getGateTypeDistribution(json: any): Record<string, number> {
    if (!json || !json.gates) return {};
    
    return json.gates.reduce((acc: Record<string, number>, gate: any) => {
      const type = gate.typ || 'Unknown';
      acc[type] = (acc[type] || 0) + 1;
      return acc;
    }, {});
  }
  
  /**
   * Deep compare two constraint system JSONs
   */
  static compareConstraintJSONs(
    snarkyJSON: any,
    sparkyJSON: any,
    operationName: string
  ): {
    identical: boolean;
    differences: any;
    summary: string;
  } {
    // Handle cases where one or both failed
    if (!snarkyJSON || !sparkyJSON) {
      return {
        identical: false,
        differences: {
          snarkyValid: !!snarkyJSON,
          sparkyValid: !!sparkyJSON
        },
        summary: 'One or both constraint systems failed to generate'
      };
    }
    
    // Compare public input sizes
    const publicInputDiff = snarkyJSON.public_input_size !== sparkyJSON.public_input_size;
    
    // Compare gate counts
    const gateCountDiff = snarkyJSON.gates.length !== sparkyJSON.gates.length;
    
    // Deep compare gates
    const gateDifferences: any[] = [];
    const maxGates = Math.max(snarkyJSON.gates.length, sparkyJSON.gates.length);
    
    for (let i = 0; i < maxGates; i++) {
      const snarkyGate = snarkyJSON.gates[i];
      const sparkyGate = sparkyJSON.gates[i];
      
      if (!snarkyGate || !sparkyGate) {
        gateDifferences.push({
          index: i,
          type: 'missing',
          snarky: snarkyGate || null,
          sparky: sparkyGate || null
        });
        continue;
      }
      
      // Compare gate types
      if (snarkyGate.typ !== sparkyGate.typ) {
        gateDifferences.push({
          index: i,
          type: 'type_mismatch',
          snarkyType: snarkyGate.typ,
          sparkyType: sparkyGate.typ
        });
      }
      
      // Compare wires
      const wiresDiff = JSON.stringify(snarkyGate.wires) !== JSON.stringify(sparkyGate.wires);
      if (wiresDiff) {
        gateDifferences.push({
          index: i,
          type: 'wires_mismatch',
          snarkyWires: snarkyGate.wires,
          sparkyWires: sparkyGate.wires
        });
      }
      
      // Compare coefficients
      const coeffsDiff = JSON.stringify(snarkyGate.coeffs) !== JSON.stringify(sparkyGate.coeffs);
      if (coeffsDiff) {
        gateDifferences.push({
          index: i,
          type: 'coeffs_mismatch',
          snarkyCoeffs: snarkyGate.coeffs,
          sparkyCoeffs: sparkyGate.coeffs
        });
      }
    }
    
    const identical = !publicInputDiff && !gateCountDiff && gateDifferences.length === 0;
    
    return {
      identical,
      differences: {
        publicInputSize: {
          snarky: snarkyJSON.public_input_size,
          sparky: sparkyJSON.public_input_size,
          matches: !publicInputDiff
        },
        gateCount: {
          snarky: snarkyJSON.gates.length,
          sparky: sparkyJSON.gates.length,
          matches: !gateCountDiff
        },
        gateDifferences,
        gateTypeDistribution: {
          snarky: this.getGateTypeDistribution(snarkyJSON),
          sparky: this.getGateTypeDistribution(sparkyJSON)
        }
      },
      summary: identical 
        ? 'Constraint systems are identical'
        : `Found ${gateDifferences.length} gate differences, gate count: ${snarkyJSON.gates.length} vs ${sparkyJSON.gates.length}`
    };
  }
}

/**
 * Test operations for comprehensive constraint system comparison
 */
const constraintJSONTestOperations = [
  // Basic arithmetic operations
  {
    name: 'basic-field-addition',
    operation: (a: Field, b: Field) => a.add(b),
    inputs: () => [Field(3), Field(5)]
  },
  
  {
    name: 'basic-field-multiplication',
    operation: (a: Field, b: Field) => a.mul(b),
    inputs: () => [Field(7), Field(11)]
  },
  
  {
    name: 'field-subtraction',
    operation: (a: Field, b: Field) => a.sub(b),
    inputs: () => [Field(100), Field(37)]
  },
  
  {
    name: 'field-division',
    operation: (a: Field, b: Field) => a.div(b),
    inputs: () => [Field(48), Field(6)]
  },
  
  // Boolean operations
  {
    name: 'boolean-and',
    operation: (a: Bool, b: Bool) => a.and(b),
    inputs: () => [Bool(true), Bool(false)]
  },
  
  {
    name: 'boolean-or',
    operation: (a: Bool, b: Bool) => a.or(b),
    inputs: () => [Bool(true), Bool(false)]
  },
  
  {
    name: 'boolean-not',
    operation: (a: Bool) => a.not(),
    inputs: () => [Bool(true)]
  },
  
  {
    name: 'boolean-equals',
    operation: (a: Bool, b: Bool) => a.equals(b),
    inputs: () => [Bool(false), Bool(false)]
  },
  
  // Conditional operations
  {
    name: 'provable-if-fields',
    operation: (cond: Bool, a: Field, b: Field) => Provable.if(cond, a, b),
    inputs: () => [Bool(true), Field(42), Field(17)]
  },
  
  // Comparison operations
  {
    name: 'field-less-than',
    operation: (a: Field, b: Field) => a.lessThan(b),
    inputs: () => [Field(10), Field(20)]
  },
  
  {
    name: 'field-less-than-or-equal',
    operation: (a: Field, b: Field) => a.lessThanOrEqual(b),
    inputs: () => [Field(15), Field(15)]
  },
  
  {
    name: 'field-greater-than',
    operation: (a: Field, b: Field) => a.greaterThan(b),
    inputs: () => [Field(30), Field(25)]
  },
  
  // Assertions
  {
    name: 'field-assert-equals',
    operation: (a: Field, b: Field) => {
      a.assertEquals(b);
      return Bool(true);
    },
    inputs: () => [Field(42), Field(42)]
  },
  
  {
    name: 'field-assert-not-equals',
    operation: (a: Field, b: Field) => {
      a.assertNotEquals(b);
      return Bool(true);
    },
    inputs: () => [Field(10), Field(20)]
  },
  
  // Complex operations
  {
    name: 'poseidon-hash-two-fields',
    operation: (a: Field, b: Field) => Poseidon.hash([a, b]),
    inputs: () => [Field(123), Field(456)]
  },
  
  {
    name: 'complex-arithmetic-expression',
    operation: (a: Field, b: Field, c: Field) => {
      // (a + b) * c - a
      const sum = a.add(b);
      const product = sum.mul(c);
      return product.sub(a);
    },
    inputs: () => [Field(2), Field(3), Field(4)]
  },
  
  {
    name: 'nested-conditionals',
    operation: (cond1: Bool, cond2: Bool, a: Field, b: Field, c: Field) => {
      // if cond1 then (if cond2 then a else b) else c
      const innerResult = Provable.if(cond2, a, b);
      return Provable.if(cond1, innerResult, c);
    },
    inputs: () => [Bool(true), Bool(false), Field(1), Field(2), Field(3)]
  },
  
  // Witness patterns
  {
    name: 'witness-field-pattern',
    operation: (expected: Field) => {
      const witness = Provable.witness(Field, () => expected);
      witness.assertEquals(expected);
      return witness;
    },
    inputs: () => [Field(999)]
  },
  
  // UInt operations
  {
    name: 'uint32-addition',
    operation: (a: UInt32, b: UInt32) => a.add(b),
    inputs: () => [UInt32.from(100), UInt32.from(200)]
  },
  
  {
    name: 'uint64-comparison',
    operation: (a: UInt64, b: UInt64) => a.lessThan(b),
    inputs: () => [UInt64.from(1000n), UInt64.from(2000n)]
  },
  
  // Group operations
  {
    name: 'group-addition',
    operation: (a: Group, b: Group) => a.add(b),
    inputs: () => [Group.generator, Group.generator]
  },
  
  // Array operations
  {
    name: 'array-field-sum',
    operation: (a: Field, b: Field, c: Field) => {
      const arr = [a, b, c];
      return arr.reduce((acc, val) => acc.add(val), Field(0));
    },
    inputs: () => [Field(10), Field(20), Field(30)]
  }
];

/**
 * Create constraint JSON comparison tests
 */
function createConstraintJSONTests(): ConstraintJSONTestCase[] {
  return constraintJSONTestOperations.map(op => ({
    name: `constraint-json-${op.name}`,
    type: 'comparison' as const,
    compareBy: 'json' as const,
    timeout: 30000,
    testFn: async (backend) => {
      console.log(`🔬 Generating constraint system JSON for ${op.name} on ${backend}`);
      
      try {
        const inputs = op.inputs();
        
        // Get constraint system as JSON
        const result = await ConstraintSystemJSONComparer.getConstraintSystemJSON(
          op.operation as any,
          inputs,
          op.name,
          backend
        );
        
        return {
          backend,
          operationName: op.name,
          success: result.success,
          error: result.error,
          constraintJSON: result.json,
          stats: result.stats
        };
        
      } catch (error) {
        return {
          backend,
          operationName: op.name,
          success: false,
          error: error instanceof Error ? error.message : String(error),
          constraintJSON: null,
          stats: null
        };
      }
    }
  }));
}

/**
 * Special edge case tests
 */
const edgeCaseTests: ConstraintJSONTestCase[] = [
  {
    name: 'constraint-json-empty-circuit',
    type: 'comparison',
    compareBy: 'json',
    timeout: 30000,
    testFn: async (backend) => {
      console.log(`🔬 Testing empty circuit constraint system on ${backend}`);
      
      try {
        const result = await ConstraintSystemJSONComparer.getConstraintSystemJSON(
          () => { /* empty circuit */ },
          [],
          'empty-circuit',
          backend
        );
        
        return {
          backend,
          operationName: 'empty-circuit',
          success: result.success,
          constraintJSON: result.json,
          stats: result.stats
        };
      } catch (error) {
        return {
          backend,
          operationName: 'empty-circuit',
          success: false,
          error: error instanceof Error ? error.message : String(error)
        };
      }
    }
  },
  
  {
    name: 'constraint-json-constants-only',
    type: 'comparison',
    compareBy: 'json',
    timeout: 30000,
    testFn: async (backend) => {
      console.log(`🔬 Testing constants-only circuit on ${backend}`);
      
      try {
        const result = await ConstraintSystemJSONComparer.getConstraintSystemJSON(
          () => {
            const a = Field(5);
            const b = Field(10);
            return a.add(b); // Should be constant-folded
          },
          [],
          'constants-only',
          backend
        );
        
        return {
          backend,
          operationName: 'constants-only',
          success: result.success,
          constraintJSON: result.json,
          stats: result.stats
        };
      } catch (error) {
        return {
          backend,
          operationName: 'constants-only',
          success: false,
          error: error instanceof Error ? error.message : String(error)
        };
      }
    }
  }
];

// Export all tests
export const tests: ConstraintJSONTestCase[] = [
  ...createConstraintJSONTests(),
  ...edgeCaseTests
];

// Export the comparer for use in analysis
export { ConstraintSystemJSONComparer };