/**
 * DEBUG CONSTRAINT STRUCTURE
 * 
 * Examines the actual constraint structure generated by Sparky
 * to understand why variable mapping is failing.
 */

import { Field, ZkProgram, Provable, switchBackend, getCurrentBackend } from './dist/node/index.js';

async function debugConstraintStructure() {
  console.log('üîç DEBUG CONSTRAINT STRUCTURE ANALYSIS');
  console.log('='.repeat(60));

  try {
    console.log('\nüü† Sparky backend - Examining actual constraint structure:');
    await switchBackend('sparky');
    
    // Generate a constraint we can examine
    const sparkyConstraints = await Provable.constraintSystem(() => {
      console.log('üîß Inside Sparky constraint analysis');
      const a = Field(3);
      const b = Field(4);
      const c = a.mul(b); // This should generate 1 constraint
      console.log('üîß Sparky constraint generation completed');
      return c;
    });
    
    console.log(`üìä Sparky constraints: ${sparkyConstraints.gates?.length || 0} gates`);
    
    if (sparkyConstraints.gates?.length > 0) {
      console.log('üéâ Sparky generated constraints! Examining structure...');
      
      // Print the full constraint structure
      console.log('\nüìã FULL SPARKY CONSTRAINT SYSTEM:');
      console.log(JSON.stringify(sparkyConstraints, null, 2));
      
      const firstGate = sparkyConstraints.gates[0];
      console.log('\nüîç FIRST GATE DETAILED ANALYSIS:');
      console.log(`Gate type: ${firstGate.typ}`);
      console.log(`Wires (${firstGate.wires?.length}):`, JSON.stringify(firstGate.wires, null, 2));
      console.log(`Coeffs (${firstGate.coeffs?.length}):`, JSON.stringify(firstGate.coeffs, null, 2));
      
      // Analyze wire pattern
      if (firstGate.wires?.length > 0) {
        console.log('\nüîç WIRE PATTERN ANALYSIS:');
        firstGate.wires.forEach((wire, index) => {
          console.log(`Wire ${index}: row=${wire.row}, col=${wire.col}`);
        });
        
        // Check if all wires point to row 0 (the problem)
        const allRowZero = firstGate.wires.every(wire => wire.row === 0);
        if (allRowZero) {
          console.log('‚ùå ISSUE CONFIRMED: All wires point to row 0');
          console.log('üéØ This is the root cause of the permutation failure');
        } else {
          console.log('‚úÖ Wire distribution looks correct');
        }
      }
      
      // If we have access to the constraint bridge, examine its raw data
      if (globalThis.sparkyConstraintBridge?.getFullConstraintSystem) {
        console.log('\nüìã SPARKY RAW CONSTRAINT SYSTEM:');
        const rawSystem = globalThis.sparkyConstraintBridge.getFullConstraintSystem();
        console.log(JSON.stringify(rawSystem, null, 2));
      }
    } else {
      console.log('‚ùå No constraints generated - this is unexpected for multiplication');
    }
    
    // Now test with a ZkProgram to see the difference
    console.log('\nüß™ ZKPROGRAM CONSTRAINT STRUCTURE:');
    
    const MultiplyProgram = ZkProgram({
      name: 'MultiplyProgram',
      publicInput: Field,
      publicOutput: Field,
      methods: {
        multiply: {
          privateInputs: [Field],
          async method(publicInput, privateInput) {
            console.log('üîß Inside ZkProgram multiply method');
            const result = publicInput.mul(privateInput);
            console.log('üîß Multiplication completed');
            return { publicOutput: result };
          },
        },
      },
    });
    
    console.log('Compiling ZkProgram...');
    await MultiplyProgram.compile();
    
    // Extract constraints after compilation
    if (globalThis.sparkyConstraintBridge?.getFullConstraintSystem) {
      console.log('\nüìã ZKPROGRAM CONSTRAINT SYSTEM:');
      const zkprogramSystem = globalThis.sparkyConstraintBridge.getFullConstraintSystem();
      console.log(JSON.stringify(zkprogramSystem, null, 2));
      
      if (zkprogramSystem.gates?.length > 0) {
        const gate = zkprogramSystem.gates[0];
        console.log('\nüîç ZKPROGRAM GATE ANALYSIS:');
        console.log(`Gate type: ${gate.typ}`);
        console.log(`Wires:`, JSON.stringify(gate.wires, null, 2));
        console.log(`Coeffs:`, JSON.stringify(gate.coeffs, null, 2));
        
        // Check wire distribution
        const wireRows = gate.wires.map(w => w.row);
        const uniqueRows = [...new Set(wireRows)];
        console.log(`Wire rows: [${wireRows.join(', ')}]`);
        console.log(`Unique rows: [${uniqueRows.join(', ')}]`);
        
        if (uniqueRows.length === 1 && uniqueRows[0] === 0) {
          console.log('‚ùå CONFIRMED: All variables map to row 0');
          console.log('üéØ Variable-to-row mapping bug is the root cause');
        } else {
          console.log('‚úÖ Wire distribution appears correct');
        }
      }
    }

  } catch (error) {
    console.error(`‚ùå Analysis failed: ${error.message}`);
    console.error(error.stack);
  }
}

// Run the analysis
debugConstraintStructure().catch(console.error);